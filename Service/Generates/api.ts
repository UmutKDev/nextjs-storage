/* tslint:disable */
/* eslint-disable */
/**
 * Base API Service
 * Base API Service Test Environment & Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccountChangePasswordRequestModel {
    'current_password': string;
    'new_password': string;
    'new_password_confirmation': string;
}
export interface AccountProfileResponseGetModel {
    'result': AccountProfileResponseModel;
    'status': BaseStatusModel;
}
export interface AccountProfileResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'avatar': string;
    'role': AccountProfileResponseModelRoleEnum;
    'status': AccountProfileResponseModelStatusEnum;
    'date': UserDateModel;
}

export const AccountProfileResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type AccountProfileResponseModelRoleEnum = typeof AccountProfileResponseModelRoleEnum[keyof typeof AccountProfileResponseModelRoleEnum];
export const AccountProfileResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type AccountProfileResponseModelStatusEnum = typeof AccountProfileResponseModelStatusEnum[keyof typeof AccountProfileResponseModelStatusEnum];

export interface AccountPutBodyRequestModel {
    'fullName': string;
    'phoneNumber': string;
}
export interface ArrayResponseModel {
    'options': PaginationResponseModel;
    'items': Array<Array<string>>;
}
export interface AuthenticationDecodeTokenBodyRequestModel {
    'token': string;
}
export interface AuthenticationRefreshTokenRequestModel {
    'refreshToken': string;
}
export interface AuthenticationResetPasswordRequestModel {
    'email': string;
}
export interface AuthenticationSignInRequestModel {
    'email': string;
    'password': string;
}
export interface AuthenticationSignUpRequestModel {
    'email': string;
    'password': string;
    'password_confirmation': string;
}
export interface AuthenticationTokenResponseGetModel {
    'result': AuthenticationTokenResponseModel;
    'status': BaseStatusModel;
}
export interface AuthenticationTokenResponseModel {
    'accessToken': string;
    'refreshToken': string;
    'expiresIn': number;
}
export interface BaseDateModel {
    'created': string;
    'updated': string;
}
export interface BaseResponseModel {
    'result': object;
    'status': BaseStatusModel;
}
export interface BaseStatusModel {
    'messages': Array<string>;
    'code': number;
    'timestamp': string;
    'path': string;
}
export interface BooleanResponseModel {
    'result': boolean;
    'status': BaseStatusModel;
}
export interface Check200Response {
    'status'?: string;
    'info'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'error'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'details'?: { [key: string]: Check200ResponseInfoValue; };
}
export interface Check200ResponseInfoValue {
    [key: string]: any;

    'status': string;
}
export interface Check503Response {
    'status'?: string;
    'info'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'error'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'details'?: { [key: string]: Check200ResponseInfoValue; };
}
export interface CloudAbortMultipartUploadRequestModel {
    'Key': string;
    'UploadId': string;
}
export interface CloudBreadCrumbModel {
    'Name': string;
    'Path': string;
    'Type': CloudBreadCrumbModelTypeEnum;
}

export const CloudBreadCrumbModelTypeEnum = {
    Root: 'ROOT',
    Subfolder: 'SUBFOLDER'
} as const;

export type CloudBreadCrumbModelTypeEnum = typeof CloudBreadCrumbModelTypeEnum[keyof typeof CloudBreadCrumbModelTypeEnum];

export interface CloudCompleteMultipartUploadRequestModel {
    'Key': string;
    'UploadId': string;
    'Parts': Array<CloudMultipartPartModel>;
}
export interface CloudCompleteMultipartUploadResponseGetModel {
    'result': CloudCompleteMultipartUploadResponseModel;
    'status': BaseStatusModel;
}
export interface CloudCompleteMultipartUploadResponseModel {
    'Location': string;
    'Key': string;
    'Bucket': string;
    'ETag': string;
    'Metadata'?: object;
}
export interface CloudCreateMultipartUploadRequestModel {
    'Key': string;
    'ContentType'?: string;
    'Metadata'?: object;
}
export interface CloudCreateMultipartUploadResponseGetModel {
    'result': CloudCreateMultipartUploadResponseModel;
    'status': BaseStatusModel;
}
export interface CloudCreateMultipartUploadResponseModel {
    'UploadId': string;
    'Key': string;
}
export interface CloudDeleteRequestModel {
    'Key': Array<string>;
    'IsDirectory'?: boolean;
}
export interface CloudDirectoryModel {
    'Prefix': string;
}
export interface CloudGetMultipartPartUrlRequestModel {
    'Key': string;
    'UploadId': string;
    'PartNumber': number;
}
export interface CloudGetMultipartPartUrlResponseGetModel {
    'result': CloudGetMultipartPartUrlResponseModel;
    'status': BaseStatusModel;
}
export interface CloudGetMultipartPartUrlResponseModel {
    'Url': string;
    'Expires': number;
}
export interface CloudKeyRequestModel {
    'Key': string;
}
export interface CloudListResponseGetModel {
    'result': CloudListResponseModel;
    'status': BaseStatusModel;
}
export interface CloudListResponseModel {
    'Breadcrumb': Array<CloudBreadCrumbModel>;
    'Directories': Array<CloudDirectoryModel>;
    'Contents': Array<CloudObjectModel>;
}
export interface CloudMoveRequestModel {
    'SourceKey': string;
    'DestinationKey': string;
}
export interface CloudMultipartPartModel {
    'PartNumber': number;
    'ETag': string;
}
export interface CloudObjectModel {
    'Name': string;
    'Extension': string;
    'MimeType': string;
    'Path': CloudPathModel;
    'Metadata': object;
    'LastModified': string;
    'ETag': string;
    'Size': number;
}
export interface CloudPathModel {
    'Host': string;
    'Key': string;
    'Url': string;
}
export interface CloudUploadPartResponseGetModel {
    'result': CloudUploadPartResponseModel;
    'status': BaseStatusModel;
}
export interface CloudUploadPartResponseModel {
    'ETag': string;
}
export interface DefinitionGroupResponseListModel {
    'result': DefinitionGroupResponseListResultModelResult;
    'status': BaseStatusModel;
}
export interface DefinitionGroupResponseListResultModelResult {
    'options': PaginationResponseModel;
    'items': Array<DefinitionGroupResponseModel>;
}
export interface DefinitionGroupResponseModel {
    'id': string;
    'code': string;
    'description': string;
    'isCommon': boolean;
    'date': BaseDateModel;
}
export interface InternalServerErrorResponseModel {
    'result': any;
    'status': InternalServerErrorResponseModelAllOfStatus;
}
export interface InternalServerErrorResponseModel1 {
    'result': string;
    'status': InternalServerErrorResponseModelAllOfStatus;
}
export interface InternalServerErrorResponseModelAllOfStatus {
    'code'?: number;
    'message'?: string;
}
export interface JWTTokenDecodeResponseGetModel {
    'result': JWTTokenDecodeResponseModel;
    'status': BaseStatusModel;
}
export interface JWTTokenDecodeResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'role': JWTTokenDecodeResponseModelRoleEnum;
    'status': JWTTokenDecodeResponseModelStatusEnum;
    'iat': number;
    'exp': number;
}

export const JWTTokenDecodeResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type JWTTokenDecodeResponseModelRoleEnum = typeof JWTTokenDecodeResponseModelRoleEnum[keyof typeof JWTTokenDecodeResponseModelRoleEnum];
export const JWTTokenDecodeResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type JWTTokenDecodeResponseModelStatusEnum = typeof JWTTokenDecodeResponseModelStatusEnum[keyof typeof JWTTokenDecodeResponseModelStatusEnum];

export interface PaginationResponseModel {
    'search': string;
    'skip': number;
    'take': number;
    'count': number;
}
export interface StringResponseModel {
    'result': string;
    'status': BaseStatusModel;
}
export interface UploadPartRequest {
    'Key'?: string;
    'UploadId'?: string;
    'PartNumber'?: number;
    'File'?: File;
}
export interface UserDateModel {
    'created': string;
    'updated': string;
    'lastLogin': string;
}
export interface UserFindResponseGetModel {
    'result': UserFindResponseModel;
    'status': BaseStatusModel;
}
export interface UserFindResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'avatar': string;
    'role': UserFindResponseModelRoleEnum;
    'status': UserFindResponseModelStatusEnum;
    'date': UserDateModel;
}

export const UserFindResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserFindResponseModelRoleEnum = typeof UserFindResponseModelRoleEnum[keyof typeof UserFindResponseModelRoleEnum];
export const UserFindResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserFindResponseModelStatusEnum = typeof UserFindResponseModelStatusEnum[keyof typeof UserFindResponseModelStatusEnum];

export interface UserListResponseListModel {
    'result': UserListResponseListResultModelResult;
    'status': BaseStatusModel;
}
export interface UserListResponseListResultModelResult {
    'options': PaginationResponseModel;
    'items': Array<UserListResponseModel>;
}
export interface UserListResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'avatar': string;
    'role': UserListResponseModelRoleEnum;
    'status': UserListResponseModelStatusEnum;
    'date': UserDateModel;
}

export const UserListResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserListResponseModelRoleEnum = typeof UserListResponseModelRoleEnum[keyof typeof UserListResponseModelRoleEnum];
export const UserListResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserListResponseModelStatusEnum = typeof UserListResponseModelStatusEnum[keyof typeof UserListResponseModelStatusEnum];

export interface UserPostBodyRequestModel {
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'avatar': string;
    'role': UserPostBodyRequestModelRoleEnum;
    'status': UserPostBodyRequestModelStatusEnum;
}

export const UserPostBodyRequestModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserPostBodyRequestModelRoleEnum = typeof UserPostBodyRequestModelRoleEnum[keyof typeof UserPostBodyRequestModelRoleEnum];
export const UserPostBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserPostBodyRequestModelStatusEnum = typeof UserPostBodyRequestModelStatusEnum[keyof typeof UserPostBodyRequestModelStatusEnum];

export interface UserPutBodyRequestModel {
    'fullName': string;
    'phoneNumber': string;
    'avatar': string;
    'role': UserPutBodyRequestModelRoleEnum;
    'status': UserPutBodyRequestModelStatusEnum;
}

export const UserPutBodyRequestModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserPutBodyRequestModelRoleEnum = typeof UserPutBodyRequestModelRoleEnum[keyof typeof UserPutBodyRequestModelRoleEnum];
export const UserPutBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserPutBodyRequestModelStatusEnum = typeof UserPutBodyRequestModelStatusEnum[keyof typeof UserPutBodyRequestModelStatusEnum];


/**
 * AccountApi - axios parameter creator
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AccountChangePasswordRequestModel} accountChangePasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (accountChangePasswordRequestModel: AccountChangePasswordRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountChangePasswordRequestModel' is not null or undefined
            assertParamExists('changePassword', 'accountChangePasswordRequestModel', accountChangePasswordRequestModel)
            const localVarPath = `/Api/Account/ChangePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountChangePasswordRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountPutBodyRequestModel} accountPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (accountPutBodyRequestModel: AccountPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'accountPutBodyRequestModel', accountPutBodyRequestModel)
            const localVarPath = `/Api/Account/Edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AccountChangePasswordRequestModel} accountChangePasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(accountChangePasswordRequestModel: AccountChangePasswordRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(accountChangePasswordRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountPutBodyRequestModel} accountPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(accountPutBodyRequestModel: AccountPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(accountPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountProfileResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.profile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {AccountApiChangePasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestParameters: AccountApiChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.changePassword(requestParameters.accountChangePasswordRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: AccountApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.accountPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(options?: RawAxiosRequestConfig): AxiosPromise<AccountProfileResponseGetModel> {
            return localVarFp.profile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePassword operation in AccountApi.
 */
export interface AccountApiChangePasswordRequest {
    readonly accountChangePasswordRequestModel: AccountChangePasswordRequestModel
}

/**
 * Request parameters for edit operation in AccountApi.
 */
export interface AccountApiEditRequest {
    readonly accountPutBodyRequestModel: AccountPutBodyRequestModel
}

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {AccountApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changePassword(requestParameters: AccountApiChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).changePassword(requestParameters.accountChangePasswordRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: AccountApiEditRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).edit(requestParameters.accountPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profile(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).profile(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthenticationDecodeTokenBodyRequestModel} authenticationDecodeTokenBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodeToken: async (authenticationDecodeTokenBodyRequestModel: AuthenticationDecodeTokenBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationDecodeTokenBodyRequestModel' is not null or undefined
            assertParamExists('decodeToken', 'authenticationDecodeTokenBodyRequestModel', authenticationDecodeTokenBodyRequestModel)
            const localVarPath = `/Api/Authentication/DecodeToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationDecodeTokenBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthenticationSignInRequestModel} authenticationSignInRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (authenticationSignInRequestModel: AuthenticationSignInRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationSignInRequestModel' is not null or undefined
            assertParamExists('login', 'authenticationSignInRequestModel', authenticationSignInRequestModel)
            const localVarPath = `/Api/Authentication/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationSignInRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout and revoke refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationRefreshTokenRequestModel' is not null or undefined
            assertParamExists('logout', 'authenticationRefreshTokenRequestModel', authenticationRefreshTokenRequestModel)
            const localVarPath = `/Api/Authentication/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRefreshTokenRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token using refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationRefreshTokenRequestModel' is not null or undefined
            assertParamExists('refreshToken', 'authenticationRefreshTokenRequestModel', authenticationRefreshTokenRequestModel)
            const localVarPath = `/Api/Authentication/RefreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRefreshTokenRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {AuthenticationSignUpRequestModel} authenticationSignUpRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (authenticationSignUpRequestModel: AuthenticationSignUpRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationSignUpRequestModel' is not null or undefined
            assertParamExists('register', 'authenticationSignUpRequestModel', authenticationSignUpRequestModel)
            const localVarPath = `/Api/Authentication/Register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationSignUpRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthenticationResetPasswordRequestModel} authenticationResetPasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (authenticationResetPasswordRequestModel: AuthenticationResetPasswordRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationResetPasswordRequestModel' is not null or undefined
            assertParamExists('resetPassword', 'authenticationResetPasswordRequestModel', authenticationResetPasswordRequestModel)
            const localVarPath = `/Api/Authentication/ResetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationResetPasswordRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthenticationDecodeTokenBodyRequestModel} authenticationDecodeTokenBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decodeToken(authenticationDecodeTokenBodyRequestModel: AuthenticationDecodeTokenBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JWTTokenDecodeResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decodeToken(authenticationDecodeTokenBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.decodeToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthenticationSignInRequestModel} authenticationSignInRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(authenticationSignInRequestModel: AuthenticationSignInRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(authenticationSignInRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout and revoke refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(authenticationRefreshTokenRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token using refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(authenticationRefreshTokenRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {AuthenticationSignUpRequestModel} authenticationSignUpRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(authenticationSignUpRequestModel: AuthenticationSignUpRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(authenticationSignUpRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthenticationResetPasswordRequestModel} authenticationResetPasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(authenticationResetPasswordRequestModel: AuthenticationResetPasswordRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(authenticationResetPasswordRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthenticationApiDecodeTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decodeToken(requestParameters: AuthenticationApiDecodeTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<JWTTokenDecodeResponseGetModel> {
            return localVarFp.decodeToken(requestParameters.authenticationDecodeTokenBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenResponseGetModel> {
            return localVarFp.login(requestParameters.authenticationSignInRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout and revoke refresh token
         * @param {AuthenticationApiLogoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(requestParameters: AuthenticationApiLogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.logout(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token using refresh token
         * @param {AuthenticationApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthenticationApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenResponseGetModel> {
            return localVarFp.refreshToken(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenResponseGetModel> {
            return localVarFp.register(requestParameters.authenticationSignUpRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.resetPassword(requestParameters.authenticationResetPasswordRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for decodeToken operation in AuthenticationApi.
 */
export interface AuthenticationApiDecodeTokenRequest {
    readonly authenticationDecodeTokenBodyRequestModel: AuthenticationDecodeTokenBodyRequestModel
}

/**
 * Request parameters for login operation in AuthenticationApi.
 */
export interface AuthenticationApiLoginRequest {
    readonly authenticationSignInRequestModel: AuthenticationSignInRequestModel
}

/**
 * Request parameters for logout operation in AuthenticationApi.
 */
export interface AuthenticationApiLogoutRequest {
    readonly authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel
}

/**
 * Request parameters for refreshToken operation in AuthenticationApi.
 */
export interface AuthenticationApiRefreshTokenRequest {
    readonly authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel
}

/**
 * Request parameters for register operation in AuthenticationApi.
 */
export interface AuthenticationApiRegisterRequest {
    readonly authenticationSignUpRequestModel: AuthenticationSignUpRequestModel
}

/**
 * Request parameters for resetPassword operation in AuthenticationApi.
 */
export interface AuthenticationApiResetPasswordRequest {
    readonly authenticationResetPasswordRequestModel: AuthenticationResetPasswordRequestModel
}

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticationApiDecodeTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public decodeToken(requestParameters: AuthenticationApiDecodeTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).decodeToken(requestParameters.authenticationDecodeTokenBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(requestParameters.authenticationSignInRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout and revoke refresh token
     * @param {AuthenticationApiLogoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(requestParameters: AuthenticationApiLogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token using refresh token
     * @param {AuthenticationApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(requestParameters: AuthenticationApiRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshToken(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(requestParameters.authenticationSignUpRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPassword(requestParameters.authenticationResetPasswordRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudApi - axios parameter creator
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CloudDeleteRequestModel} cloudDeleteRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (cloudDeleteRequestModel: CloudDeleteRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudDeleteRequestModel' is not null or undefined
            assertParamExists('_delete', 'cloudDeleteRequestModel', cloudDeleteRequestModel)
            const localVarPath = `/Api/Cloud/Delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudDeleteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloudKeyRequestModel} cloudKeyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDirectory: async (cloudKeyRequestModel: CloudKeyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudKeyRequestModel' is not null or undefined
            assertParamExists('createDirectory', 'cloudKeyRequestModel', cloudKeyRequestModel)
            const localVarPath = `/Api/Cloud/CreateDirectory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudKeyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('find', 'key', key)
            const localVarPath = `/Api/Cloud/Find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrl: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPresignedUrl', 'key', key)
            const localVarPath = `/Api/Cloud/PresignedUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }

            if (isMetadataProcessing !== undefined) {
                localVarQueryParameter['IsMetadataProcessing'] = isMetadataProcessing;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloudMoveRequestModel} cloudMoveRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move: async (cloudMoveRequestModel: CloudMoveRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudMoveRequestModel' is not null or undefined
            assertParamExists('move', 'cloudMoveRequestModel', cloudMoveRequestModel)
            const localVarPath = `/Api/Cloud/Move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudMoveRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloudAbortMultipartUploadRequestModel} cloudAbortMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAbortMultipartUpload: async (cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudAbortMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadAbortMultipartUpload', 'cloudAbortMultipartUploadRequestModel', cloudAbortMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/AbortMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudAbortMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloudCompleteMultipartUploadRequestModel} cloudCompleteMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompleteMultipartUpload: async (cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudCompleteMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadCompleteMultipartUpload', 'cloudCompleteMultipartUploadRequestModel', cloudCompleteMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/CompleteMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudCompleteMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloudCreateMultipartUploadRequestModel} cloudCreateMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCreateMultipartUpload: async (cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudCreateMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadCreateMultipartUpload', 'cloudCreateMultipartUploadRequestModel', cloudCreateMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/CreateMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudCreateMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CloudGetMultipartPartUrlRequestModel} cloudGetMultipartPartUrlRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGetMultipartPartUrl: async (cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudGetMultipartPartUrlRequestModel' is not null or undefined
            assertParamExists('uploadGetMultipartPartUrl', 'cloudGetMultipartPartUrlRequestModel', cloudGetMultipartPartUrlRequestModel)
            const localVarPath = `/Api/Cloud/Upload/GetMultipartPartUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudGetMultipartPartUrlRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [key] 
         * @param {string} [uploadId] 
         * @param {number} [partNumber] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart: async (key?: string, uploadId?: string, partNumber?: number, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/Upload/UploadPart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (key !== undefined) { 
                localVarFormParams.append('Key', key as any);
            }
    
            if (uploadId !== undefined) { 
                localVarFormParams.append('UploadId', uploadId as any);
            }
    
            if (partNumber !== undefined) { 
                localVarFormParams.append('PartNumber', partNumber as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CloudDeleteRequestModel} cloudDeleteRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(cloudDeleteRequestModel: CloudDeleteRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(cloudDeleteRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloudKeyRequestModel} cloudKeyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDirectory(cloudKeyRequestModel: CloudKeyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDirectory(cloudKeyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.createDirectory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrl(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrl(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getPresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudListResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(path, delimiter, isMetadataProcessing, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloudMoveRequestModel} cloudMoveRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async move(cloudMoveRequestModel: CloudMoveRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(cloudMoveRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.move']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloudAbortMultipartUploadRequestModel} cloudAbortMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAbortMultipartUpload(cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAbortMultipartUpload(cloudAbortMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadAbortMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloudCompleteMultipartUploadRequestModel} cloudCompleteMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCompleteMultipartUpload(cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudCompleteMultipartUploadResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCompleteMultipartUpload(cloudCompleteMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadCompleteMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloudCreateMultipartUploadRequestModel} cloudCreateMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCreateMultipartUpload(cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudCreateMultipartUploadResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCreateMultipartUpload(cloudCreateMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadCreateMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {CloudGetMultipartPartUrlRequestModel} cloudGetMultipartPartUrlRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGetMultipartPartUrl(cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudGetMultipartPartUrlResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGetMultipartPartUrl(cloudGetMultipartPartUrlRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadGetMultipartPartUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [key] 
         * @param {string} [uploadId] 
         * @param {number} [partNumber] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPart(key?: string, uploadId?: string, partNumber?: number, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUploadPartResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPart(key, uploadId, partNumber, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudApi - factory interface
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * 
         * @param {CloudApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: CloudApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(requestParameters.cloudDeleteRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiCreateDirectoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDirectory(requestParameters: CloudApiCreateDirectoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createDirectory(requestParameters.cloudKeyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: CloudApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.find(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiGetPresignedUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrl(requestParameters: CloudApiGetPresignedUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPresignedUrl(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: CloudApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudListResponseGetModel> {
            return localVarFp.list(requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiMoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(requestParameters: CloudApiMoveRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.move(requestParameters.cloudMoveRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiUploadAbortMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAbortMultipartUpload(requestParameters: CloudApiUploadAbortMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadAbortMultipartUpload(requestParameters.cloudAbortMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiUploadCompleteMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompleteMultipartUpload(requestParameters: CloudApiUploadCompleteMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudCompleteMultipartUploadResponseGetModel> {
            return localVarFp.uploadCompleteMultipartUpload(requestParameters.cloudCompleteMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiUploadCreateMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCreateMultipartUpload(requestParameters: CloudApiUploadCreateMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudCreateMultipartUploadResponseGetModel> {
            return localVarFp.uploadCreateMultipartUpload(requestParameters.cloudCreateMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiUploadGetMultipartPartUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGetMultipartPartUrl(requestParameters: CloudApiUploadGetMultipartPartUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudGetMultipartPartUrlResponseGetModel> {
            return localVarFp.uploadGetMultipartPartUrl(requestParameters.cloudGetMultipartPartUrlRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CloudApiUploadPartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(requestParameters: CloudApiUploadPartRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudUploadPartResponseGetModel> {
            return localVarFp.uploadPart(requestParameters.key, requestParameters.uploadId, requestParameters.partNumber, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in CloudApi.
 */
export interface CloudApiDeleteRequest {
    readonly cloudDeleteRequestModel: CloudDeleteRequestModel
}

/**
 * Request parameters for createDirectory operation in CloudApi.
 */
export interface CloudApiCreateDirectoryRequest {
    readonly cloudKeyRequestModel: CloudKeyRequestModel
}

/**
 * Request parameters for find operation in CloudApi.
 */
export interface CloudApiFindRequest {
    readonly key: string
}

/**
 * Request parameters for getPresignedUrl operation in CloudApi.
 */
export interface CloudApiGetPresignedUrlRequest {
    readonly key: string
}

/**
 * Request parameters for list operation in CloudApi.
 */
export interface CloudApiListRequest {
    readonly path?: string

    readonly delimiter?: boolean

    readonly isMetadataProcessing?: boolean
}

/**
 * Request parameters for move operation in CloudApi.
 */
export interface CloudApiMoveRequest {
    readonly cloudMoveRequestModel: CloudMoveRequestModel
}

/**
 * Request parameters for uploadAbortMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadAbortMultipartUploadRequest {
    readonly cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel
}

/**
 * Request parameters for uploadCompleteMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadCompleteMultipartUploadRequest {
    readonly cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel
}

/**
 * Request parameters for uploadCreateMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadCreateMultipartUploadRequest {
    readonly cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel
}

/**
 * Request parameters for uploadGetMultipartPartUrl operation in CloudApi.
 */
export interface CloudApiUploadGetMultipartPartUrlRequest {
    readonly cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel
}

/**
 * Request parameters for uploadPart operation in CloudApi.
 */
export interface CloudApiUploadPartRequest {
    readonly key?: string

    readonly uploadId?: string

    readonly partNumber?: number

    readonly file?: File
}

/**
 * CloudApi - object-oriented interface
 */
export class CloudApi extends BaseAPI {
    /**
     * 
     * @param {CloudApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: CloudApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration)._delete(requestParameters.cloudDeleteRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiCreateDirectoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createDirectory(requestParameters: CloudApiCreateDirectoryRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).createDirectory(requestParameters.cloudKeyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: CloudApiFindRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).find(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiGetPresignedUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPresignedUrl(requestParameters: CloudApiGetPresignedUrlRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getPresignedUrl(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: CloudApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).list(requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiMoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public move(requestParameters: CloudApiMoveRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).move(requestParameters.cloudMoveRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiUploadAbortMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadAbortMultipartUpload(requestParameters: CloudApiUploadAbortMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadAbortMultipartUpload(requestParameters.cloudAbortMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiUploadCompleteMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadCompleteMultipartUpload(requestParameters: CloudApiUploadCompleteMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadCompleteMultipartUpload(requestParameters.cloudCompleteMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiUploadCreateMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadCreateMultipartUpload(requestParameters: CloudApiUploadCreateMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadCreateMultipartUpload(requestParameters.cloudCreateMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiUploadGetMultipartPartUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadGetMultipartPartUrl(requestParameters: CloudApiUploadGetMultipartPartUrlRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadGetMultipartPartUrl(requestParameters.cloudGetMultipartPartUrlRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CloudApiUploadPartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadPart(requestParameters: CloudApiUploadPartRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadPart(requestParameters.key, requestParameters.uploadId, requestParameters.partNumber, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefinitionApi - axios parameter creator
 */
export const DefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDefinition: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Find/{groupCode}/{code}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Group/Find/{groupCode}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupCode 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefinition: async (groupCode: string, search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupCode' is not null or undefined
            assertParamExists('listDefinition', 'groupCode', groupCode)
            const localVarPath = `/Api/Definition/List/{groupCode}`
                .replace(`{${"groupCode"}}`, encodeURIComponent(String(groupCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async (search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Group/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefinitionApi - functional programming interface
 */
export const DefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDefinition(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDefinition(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.findDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.findGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupCode 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDefinition(groupCode: string, search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDefinition(groupCode, search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.listDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup(search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefinitionGroupResponseListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup(search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.listGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefinitionApi - factory interface
 */
export const DefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefinitionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDefinition(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findDefinition(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefinitionApiListDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefinition(requestParameters: DefinitionApiListDefinitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listDefinition(requestParameters.groupCode, requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefinitionApiListGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(requestParameters: DefinitionApiListGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DefinitionGroupResponseListModel> {
            return localVarFp.listGroup(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listDefinition operation in DefinitionApi.
 */
export interface DefinitionApiListDefinitionRequest {
    readonly groupCode: string

    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * Request parameters for listGroup operation in DefinitionApi.
 */
export interface DefinitionApiListGroupRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * DefinitionApi - object-oriented interface
 */
export class DefinitionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findDefinition(options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).findDefinition(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findGroup(options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).findGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefinitionApiListDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDefinition(requestParameters: DefinitionApiListDefinitionRequest, options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).listDefinition(requestParameters.groupCode, requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefinitionApiListGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGroup(requestParameters: DefinitionApiListGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).listGroup(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async check(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.check(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.check']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check(options?: RawAxiosRequestConfig): AxiosPromise<Check200Response> {
            return localVarFp.check(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public check(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).check(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HomeApi - axios parameter creator
 */
export const HomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeApi - functional programming interface
 */
export const HomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async home(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.home(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeApi.home']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HomeApi - factory interface
 */
export const HomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home(options?: RawAxiosRequestConfig): AxiosPromise<StringResponseModel> {
            return localVarFp.home(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeApi - object-oriented interface
 */
export class HomeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public home(options?: RawAxiosRequestConfig) {
        return HomeApiFp(this.configuration).home(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/Api/User/Delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserPostBodyRequestModel} userPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (userPostBodyRequestModel: UserPostBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPostBodyRequestModel' is not null or undefined
            assertParamExists('create', 'userPostBodyRequestModel', userPostBodyRequestModel)
            const localVarPath = `/Api/User/Create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPostBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserPutBodyRequestModel} userPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (id: string, userPutBodyRequestModel: UserPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edit', 'id', id)
            // verify required parameter 'userPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'userPutBodyRequestModel', userPutBodyRequestModel)
            const localVarPath = `/Api/User/Edit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('find', 'id', id)
            const localVarPath = `/Api/User/Find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/User/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserPostBodyRequestModel} userPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(userPostBodyRequestModel: UserPostBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(userPostBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UserPutBodyRequestModel} userPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(id: string, userPutBodyRequestModel: UserPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(id, userPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFindResponseGetModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponseListModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {UserApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: UserApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp._delete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: UserApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.create(requestParameters.userPostBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: UserApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.id, requestParameters.userPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: UserApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserFindResponseGetModel> {
            return localVarFp.find(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: UserApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponseListModel> {
            return localVarFp.list(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in UserApi.
 */
export interface UserApiDeleteRequest {
    readonly id: string
}

/**
 * Request parameters for create operation in UserApi.
 */
export interface UserApiCreateRequest {
    readonly userPostBodyRequestModel: UserPostBodyRequestModel
}

/**
 * Request parameters for edit operation in UserApi.
 */
export interface UserApiEditRequest {
    readonly id: string

    readonly userPutBodyRequestModel: UserPutBodyRequestModel
}

/**
 * Request parameters for find operation in UserApi.
 */
export interface UserApiFindRequest {
    readonly id: string
}

/**
 * Request parameters for list operation in UserApi.
 */
export interface UserApiListRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: UserApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: UserApiCreateRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).create(requestParameters.userPostBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: UserApiEditRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).edit(requestParameters.id, requestParameters.userPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: UserApiFindRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).find(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: UserApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).list(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }
}



