/* tslint:disable */
/* eslint-disable */
/**
 * Base API Service
 * Base API Service Test Environment & Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccountChangePasswordRequestModel {
    'current_password': string;
    'new_password': string;
    'new_password_confirmation': string;
}
export interface AccountProfileResponseBaseModel {
    'result': AccountProfileResponseModel;
    'status': BaseStatusModel;
}
export interface AccountProfileResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'image': string;
    'isTwoFactorEnabled': boolean;
    'role': AccountProfileResponseModelRoleEnum;
    'status': AccountProfileResponseModelStatusEnum;
    'subscription': UserSubscriptionResponseModel;
    'date': UserDateModel;
}

export const AccountProfileResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type AccountProfileResponseModelRoleEnum = typeof AccountProfileResponseModelRoleEnum[keyof typeof AccountProfileResponseModelRoleEnum];
export const AccountProfileResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type AccountProfileResponseModelStatusEnum = typeof AccountProfileResponseModelStatusEnum[keyof typeof AccountProfileResponseModelStatusEnum];

export interface AccountPutBodyRequestModel {
    'fullName': string;
    'phoneNumber': string;
}
export interface ArrayResponseModel {
    'options': PaginationResponseModel;
    'items': Array<Array<string>>;
}
export interface AuthenticationRefreshTokenRequestModel {
    'refreshToken': string;
}
export interface AuthenticationResetPasswordRequestModel {
    'email': string;
}
export interface AuthenticationSignInRequestModel {
    'email': string;
    'password': string;
    /**
     * 6 digit code from the authenticator application
     */
    'twoFactorCode'?: string;
}
export interface AuthenticationSignUpRequestModel {
    'email': string;
    'password': string;
    'password_confirmation': string;
}
export interface AuthenticationTokenResponseBaseModel {
    'result': AuthenticationTokenResponseModel;
    'status': BaseStatusModel;
}
export interface AuthenticationTokenResponseModel {
    'accessToken'?: string;
    'refreshToken'?: string;
    'expiresIn'?: number;
}
export interface AuthenticationTwoFactorGenerateResponseBaseModel {
    'result': AuthenticationTwoFactorGenerateResponseModel;
    'status': BaseStatusModel;
}
export interface AuthenticationTwoFactorGenerateResponseModel {
    /**
     * Secret key that should be stored only on the authenticator device
     */
    'secret': string;
    /**
     * otpauth URL to create QR code in authenticator applications
     */
    'otpauthUrl': string;
}
export interface AuthenticationTwoFactorVerifyRequestModel {
    /**
     * 6 digit code generated by your authenticator application
     */
    'code': string;
}
export interface AuthenticationVerifyCredentialsRequestModel {
    'email': string;
    'password': string;
}
export interface AuthenticationVerifyCredentialsResponseBaseModel {
    'result': AuthenticationVerifyCredentialsResponseModel;
    'status': BaseStatusModel;
}
export interface AuthenticationVerifyCredentialsResponseModel {
    'isValid': boolean;
    'twoFactorRequired': boolean;
}
export interface BaseDateModel {
    'created': string;
    'updated': string;
}
export interface BaseResponseModel {
    'result': object;
    'status': BaseStatusModel;
}
export interface BaseStatusModel {
    'messages': Array<string>;
    'code': number;
    'timestamp': string;
    'path': string;
}
export interface BooleanResponseModel {
    'result': boolean;
    'status': BaseStatusModel;
}
export interface Check200Response {
    'status'?: string;
    'info'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'error'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'details'?: { [key: string]: Check200ResponseInfoValue; };
}
export interface Check200ResponseInfoValue {
    [key: string]: any;

    'status': string;
}
export interface Check503Response {
    'status'?: string;
    'info'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'error'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'details'?: { [key: string]: Check200ResponseInfoValue; };
}
export interface CloudAbortMultipartUploadRequestModel {
    'Key': string;
    'UploadId': string;
}
export interface CloudBreadCrumbListBaseModel {
    'result': CloudBreadCrumbListModelResult;
    'status': BaseStatusModel;
}
export interface CloudBreadCrumbListModelResult {
    'options': PaginationResponseModel;
    'items': Array<CloudBreadCrumbModel>;
}
export interface CloudBreadCrumbModel {
    'Name': string;
    'Path': string;
    'Type': CloudBreadCrumbModelTypeEnum;
}

export const CloudBreadCrumbModelTypeEnum = {
    Root: 'ROOT',
    Subfolder: 'SUBFOLDER'
} as const;

export type CloudBreadCrumbModelTypeEnum = typeof CloudBreadCrumbModelTypeEnum[keyof typeof CloudBreadCrumbModelTypeEnum];

export interface CloudCompleteMultipartUploadRequestModel {
    'Key': string;
    'UploadId': string;
    'Parts': Array<CloudMultipartPartModel>;
}
export interface CloudCompleteMultipartUploadResponseBaseModel {
    'result': CloudCompleteMultipartUploadResponseModel;
    'status': BaseStatusModel;
}
export interface CloudCompleteMultipartUploadResponseModel {
    'Location': string;
    'Key': string;
    'Bucket': string;
    'ETag': string;
    'Metadata'?: CloudMetadataDefaultModel;
}
export interface CloudCreateMultipartUploadRequestModel {
    'Key': string;
    'ContentType'?: string;
    'Metadata'?: object;
    'TotalSize': number;
}
export interface CloudCreateMultipartUploadResponseBaseModel {
    'result': CloudCreateMultipartUploadResponseModel;
    'status': BaseStatusModel;
}
export interface CloudCreateMultipartUploadResponseModel {
    'UploadId': string;
    'Key': string;
}
export interface CloudDeleteModel {
    'Key': string;
    'IsDirectory'?: boolean;
}
export interface CloudDeleteRequestModel {
    'Items': Array<CloudDeleteModel>;
}
export interface CloudDirectoryListBaseModel {
    'result': CloudDirectoryListModelResult;
    'status': BaseStatusModel;
}
export interface CloudDirectoryListModelResult {
    'options': PaginationResponseModel;
    'items': Array<CloudDirectoryModel>;
}
export interface CloudDirectoryModel {
    'Name': string;
    'Prefix': string;
    'IsEncrypted': boolean;
    /**
     * True if encrypted folder is locked (no valid session)
     */
    'IsLocked': boolean;
}
export interface CloudGetMultipartPartUrlRequestModel {
    'Key': string;
    'UploadId': string;
    'PartNumber': number;
}
export interface CloudGetMultipartPartUrlResponseBaseModel {
    'result': CloudGetMultipartPartUrlResponseModel;
    'status': BaseStatusModel;
}
export interface CloudGetMultipartPartUrlResponseModel {
    'Url': string;
    'Expires': number;
}
export interface CloudListResponseBaseModel {
    'result': CloudListResponseModel;
    'status': BaseStatusModel;
}
export interface CloudListResponseModel {
    'Breadcrumb': Array<CloudBreadCrumbModel>;
    'Directories': Array<CloudDirectoryModel>;
    'Contents': Array<CloudObjectModel>;
}
export interface CloudMetadataDefaultModel {
    'Originalfilename': string;
    'Width': string;
    'Height': string;
}
export interface CloudMoveRequestModel {
    'SourceKeys': Array<string>;
    'DestinationKey': string;
}
export interface CloudMultipartPartModel {
    'PartNumber': number;
    'ETag': string;
}
export interface CloudObjectBaseModel {
    'result': CloudObjectModel;
    'status': BaseStatusModel;
}
export interface CloudObjectListBaseModel {
    'result': CloudObjectListModelResult;
    'status': BaseStatusModel;
}
export interface CloudObjectListModelResult {
    'options': PaginationResponseModel;
    'items': Array<CloudObjectModel>;
}
export interface CloudObjectModel {
    'Name': string;
    'Extension': string;
    'MimeType': string;
    'Path': CloudPathModel;
    'Metadata'?: CloudMetadataDefaultModel;
    'LastModified': string;
    'ETag': string;
    'Size': number;
}
export interface CloudPathModel {
    'Host': string;
    'Key': string;
    'Url': string;
}
export interface CloudUpdateRequestModel {
    'Key': string;
    'Name'?: string;
    'Metadata'?: object;
}
export interface CloudUploadPartRequestModel {
    'Key': string;
    'UploadId': string;
    'PartNumber': number;
    'File': File;
}
export interface CloudUploadPartResponseBaseModel {
    'result': CloudUploadPartResponseModel;
    'status': BaseStatusModel;
}
export interface CloudUploadPartResponseModel {
    'ETag': string;
}
export interface CloudUserStorageUsageResponseBaseModel {
    'result': CloudUserStorageUsageResponseModel;
    'status': BaseStatusModel;
}
export interface CloudUserStorageUsageResponseModel {
    'UsedStorageInBytes': number;
    'MaxStorageInBytes': number;
    'IsLimitExceeded': boolean;
    'UsagePercentage': number;
    'MaxUploadSizeBytes': number;
}
export interface DefinitionGroupResponseListBaseModel {
    'result': DefinitionGroupResponseListModelResult;
    'status': BaseStatusModel;
}
export interface DefinitionGroupResponseListModelResult {
    'options': PaginationResponseModel;
    'items': Array<DefinitionGroupResponseModel>;
}
export interface DefinitionGroupResponseModel {
    'id': string;
    'code': string;
    'description': string;
    'isCommon': boolean;
    'date': BaseDateModel;
}
export interface DirectoryConvertToEncryptedRequestModel {
    /**
     * Directory path to convert
     */
    'Path': string;
}
export interface DirectoryCreateRequestModel {
    /**
     * Directory path to create
     */
    'Path': string;
    /**
     * Create as encrypted directory
     */
    'IsEncrypted'?: boolean;
}
export interface DirectoryDecryptRequestModel {
    /**
     * Encrypted directory path to decrypt
     */
    'Path': string;
}
export interface DirectoryDeleteRequestModel {
    /**
     * Directory path to delete
     */
    'Path': string;
}
export interface DirectoryLockRequestModel {
    /**
     * Encrypted directory path to lock
     */
    'Path': string;
}
export interface DirectoryRenameRequestModel {
    /**
     * Current directory path
     */
    'Path': string;
    /**
     * New directory name (not full path)
     */
    'Name': string;
}
export interface DirectoryResponseBaseModel {
    'result': DirectoryResponseModel;
    'status': BaseStatusModel;
}
export interface DirectoryResponseModel {
    'Path': string;
    'IsEncrypted': boolean;
    'CreatedAt'?: string;
    'UpdatedAt'?: string;
}
export interface DirectoryUnlockRequestModel {
    /**
     * Encrypted directory path
     */
    'Path': string;
}
export interface DirectoryUnlockResponseBaseModel {
    'result': DirectoryUnlockResponseModel;
    'status': BaseStatusModel;
}
export interface DirectoryUnlockResponseModel {
    /**
     * Directory path that was unlocked
     */
    'Path': string;
    /**
     * Session token for subsequent requests. Pass via X-Folder-Session header.
     */
    'SessionToken': string;
    /**
     * Session expiration timestamp (Unix epoch in seconds)
     */
    'ExpiresAt': number;
    /**
     * Session TTL in seconds
     */
    'TTL': number;
}
export interface InternalServerErrorResponseModel {
    'result': any;
    'status': InternalServerErrorResponseModelAllOfStatus;
}
export interface InternalServerErrorResponseModel1 {
    'result': string;
    'status': InternalServerErrorResponseModelAllOfStatus;
}
export interface InternalServerErrorResponseModelAllOfStatus {
    'code'?: number;
    'message'?: string;
}
export interface PaginationResponseModel {
    'search': string;
    'skip': number;
    'take': number;
    'count': number;
}
export interface StringResponseModel {
    'result': string;
    'status': BaseStatusModel;
}
export interface SubscribeAsAdminRequestModel {
    'subscriptionId': string;
    'isTrial'?: boolean;
    'providerSubscriptionId'?: string;
    'userId': string;
}
export interface SubscribeRequestModel {
    'subscriptionId': string;
    'isTrial'?: boolean;
    'providerSubscriptionId'?: string;
}
export interface SubscriptionDateModel {
    'created': string;
    'updated': string;
}
export interface SubscriptionFindResponseBaseModel {
    'result': SubscriptionFindResponseModel;
    'status': BaseStatusModel;
}
export interface SubscriptionFindResponseModel {
    'id': string;
    'name': string;
    'slug': string;
    'description'?: string;
    'currency': string;
    'billingCycle': SubscriptionFindResponseModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'storageLimitBytes': number;
    'maxFileSizeBytes'?: number;
    'maxObjectCount'?: number;
    'features'?: object;
    'status': SubscriptionFindResponseModelStatusEnum;
    'isActive': boolean;
    'date': SubscriptionDateModel;
}

export const SubscriptionFindResponseModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionFindResponseModelBillingCycleEnum = typeof SubscriptionFindResponseModelBillingCycleEnum[keyof typeof SubscriptionFindResponseModelBillingCycleEnum];
export const SubscriptionFindResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionFindResponseModelStatusEnum = typeof SubscriptionFindResponseModelStatusEnum[keyof typeof SubscriptionFindResponseModelStatusEnum];

export interface SubscriptionListResponseListBaseModel {
    'result': SubscriptionListResponseListModelResult;
    'status': BaseStatusModel;
}
export interface SubscriptionListResponseListModelResult {
    'options': PaginationResponseModel;
    'items': Array<SubscriptionListResponseModel>;
}
export interface SubscriptionListResponseModel {
    'id': string;
    'name': string;
    'slug': string;
    'description'?: string;
    'currency': string;
    'billingCycle': SubscriptionListResponseModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'storageLimitBytes': number;
    'maxFileSizeBytes'?: number;
    'maxObjectCount'?: number;
    'features'?: object;
    'status': SubscriptionListResponseModelStatusEnum;
    'isActive': boolean;
    'date': SubscriptionDateModel;
}

export const SubscriptionListResponseModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionListResponseModelBillingCycleEnum = typeof SubscriptionListResponseModelBillingCycleEnum[keyof typeof SubscriptionListResponseModelBillingCycleEnum];
export const SubscriptionListResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionListResponseModelStatusEnum = typeof SubscriptionListResponseModelStatusEnum[keyof typeof SubscriptionListResponseModelStatusEnum];

export interface SubscriptionPostBodyRequestModel {
    'name': string;
    'slug': string;
    'description'?: string;
    /**
     * Price in cents
     */
    'price': number;
    'currency': string;
    'billingCycle': SubscriptionPostBodyRequestModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'storageLimitBytes': number;
    'maxFileSizeBytes'?: number;
    'maxObjectCount'?: number;
    'features'?: object;
    'status': SubscriptionPostBodyRequestModelStatusEnum;
    'isActive': boolean;
}

export const SubscriptionPostBodyRequestModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionPostBodyRequestModelBillingCycleEnum = typeof SubscriptionPostBodyRequestModelBillingCycleEnum[keyof typeof SubscriptionPostBodyRequestModelBillingCycleEnum];
export const SubscriptionPostBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionPostBodyRequestModelStatusEnum = typeof SubscriptionPostBodyRequestModelStatusEnum[keyof typeof SubscriptionPostBodyRequestModelStatusEnum];

export interface SubscriptionPutBodyRequestModel {
    'name': string;
    'description'?: string;
    /**
     * Price in cents
     */
    'price': number;
    'currency': string;
    'billingCycle': SubscriptionPutBodyRequestModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'storageLimitBytes': number;
    'maxFileSizeBytes'?: number;
    'maxObjectCount'?: number;
    'features'?: object;
    'status': SubscriptionPutBodyRequestModelStatusEnum;
    'isActive': boolean;
}

export const SubscriptionPutBodyRequestModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionPutBodyRequestModelBillingCycleEnum = typeof SubscriptionPutBodyRequestModelBillingCycleEnum[keyof typeof SubscriptionPutBodyRequestModelBillingCycleEnum];
export const SubscriptionPutBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionPutBodyRequestModelStatusEnum = typeof SubscriptionPutBodyRequestModelStatusEnum[keyof typeof SubscriptionPutBodyRequestModelStatusEnum];

export interface SubscriptionResponseModel {
    'id': string;
    'name': string;
    'slug': string;
    'description'?: string;
    'currency': string;
    'billingCycle': SubscriptionResponseModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'storageLimitBytes': number;
    'maxFileSizeBytes'?: number;
    'maxObjectCount'?: number;
    'features'?: object;
    'status': SubscriptionResponseModelStatusEnum;
    'isActive': boolean;
    'date': SubscriptionDateModel;
}

export const SubscriptionResponseModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionResponseModelBillingCycleEnum = typeof SubscriptionResponseModelBillingCycleEnum[keyof typeof SubscriptionResponseModelBillingCycleEnum];
export const SubscriptionResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionResponseModelStatusEnum = typeof SubscriptionResponseModelStatusEnum[keyof typeof SubscriptionResponseModelStatusEnum];

export interface UserDateModel {
    'created': string;
    'updated': string;
    'lastLogin': string;
}
export interface UserFindResponseBaseModel {
    'result': UserFindResponseModel;
    'status': BaseStatusModel;
}
export interface UserFindResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'image': string;
    'isTwoFactorEnabled': boolean;
    'role': UserFindResponseModelRoleEnum;
    'status': UserFindResponseModelStatusEnum;
    'subscription': UserSubscriptionResponseModel;
    'date': UserDateModel;
}

export const UserFindResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserFindResponseModelRoleEnum = typeof UserFindResponseModelRoleEnum[keyof typeof UserFindResponseModelRoleEnum];
export const UserFindResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserFindResponseModelStatusEnum = typeof UserFindResponseModelStatusEnum[keyof typeof UserFindResponseModelStatusEnum];

export interface UserListResponseListBaseModel {
    'result': UserListResponseListModelResult;
    'status': BaseStatusModel;
}
export interface UserListResponseListModelResult {
    'options': PaginationResponseModel;
    'items': Array<UserListResponseModel>;
}
export interface UserListResponseModel {
    'id': string;
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'image': string;
    'isTwoFactorEnabled': boolean;
    'role': UserListResponseModelRoleEnum;
    'status': UserListResponseModelStatusEnum;
    'subscription': UserSubscriptionResponseModel;
    'date': UserDateModel;
}

export const UserListResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserListResponseModelRoleEnum = typeof UserListResponseModelRoleEnum[keyof typeof UserListResponseModelRoleEnum];
export const UserListResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserListResponseModelStatusEnum = typeof UserListResponseModelStatusEnum[keyof typeof UserListResponseModelStatusEnum];

export interface UserPostBodyRequestModel {
    'email': string;
    'fullName': string;
    'phoneNumber': string;
    'image': string;
    'role': UserPostBodyRequestModelRoleEnum;
    'status': UserPostBodyRequestModelStatusEnum;
    'subscription': UserSubscriptionResponseModel;
}

export const UserPostBodyRequestModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserPostBodyRequestModelRoleEnum = typeof UserPostBodyRequestModelRoleEnum[keyof typeof UserPostBodyRequestModelRoleEnum];
export const UserPostBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserPostBodyRequestModelStatusEnum = typeof UserPostBodyRequestModelStatusEnum[keyof typeof UserPostBodyRequestModelStatusEnum];

export interface UserPutBodyRequestModel {
    'fullName': string;
    'phoneNumber': string;
    'image': string;
    'role': UserPutBodyRequestModelRoleEnum;
    'status': UserPutBodyRequestModelStatusEnum;
    'subscription': UserSubscriptionResponseModel;
}

export const UserPutBodyRequestModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserPutBodyRequestModelRoleEnum = typeof UserPutBodyRequestModelRoleEnum[keyof typeof UserPutBodyRequestModelRoleEnum];
export const UserPutBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserPutBodyRequestModelStatusEnum = typeof UserPutBodyRequestModelStatusEnum[keyof typeof UserPutBodyRequestModelStatusEnum];

export interface UserSubscriptionResponseListBaseModel {
    'result': UserSubscriptionResponseListModelResult;
    'status': BaseStatusModel;
}
export interface UserSubscriptionResponseListModelResult {
    'options': PaginationResponseModel;
    'items': Array<UserSubscriptionResponseModel>;
}
export interface UserSubscriptionResponseModel {
    'id': string;
    'startAt': string;
    'endAt'?: string;
    'isActive': boolean;
    'isTrial': boolean;
    /**
     * Price as cents
     */
    'price': number;
    'currency'?: string;
    'subscription'?: SubscriptionResponseModel;
    'date': BaseDateModel;
}

/**
 * AccountApi - axios parameter creator
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AccountChangePasswordRequestModel} accountChangePasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (accountChangePasswordRequestModel: AccountChangePasswordRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountChangePasswordRequestModel' is not null or undefined
            assertParamExists('changePassword', 'accountChangePasswordRequestModel', accountChangePasswordRequestModel)
            const localVarPath = `/Api/Account/ChangePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountChangePasswordRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable 2FA after validating the authenticator code
         * @param {AuthenticationTwoFactorVerifyRequestModel} authenticationTwoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTwoFactor: async (authenticationTwoFactorVerifyRequestModel: AuthenticationTwoFactorVerifyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationTwoFactorVerifyRequestModel' is not null or undefined
            assertParamExists('disableTwoFactor', 'authenticationTwoFactorVerifyRequestModel', authenticationTwoFactorVerifyRequestModel)
            const localVarPath = `/Api/Account/TwoFactor/Disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationTwoFactorVerifyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountPutBodyRequestModel} accountPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (accountPutBodyRequestModel: AccountPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'accountPutBodyRequestModel', accountPutBodyRequestModel)
            const localVarPath = `/Api/Account/Edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm the 2FA secret and enable mandatory token checks
         * @param {AuthenticationTwoFactorVerifyRequestModel} authenticationTwoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTwoFactor: async (authenticationTwoFactorVerifyRequestModel: AuthenticationTwoFactorVerifyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationTwoFactorVerifyRequestModel' is not null or undefined
            assertParamExists('enableTwoFactor', 'authenticationTwoFactorVerifyRequestModel', authenticationTwoFactorVerifyRequestModel)
            const localVarPath = `/Api/Account/TwoFactor/Enable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationTwoFactorVerifyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a new 2FA secret for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTwoFactorSecret: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/TwoFactor/Generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AccountChangePasswordRequestModel} accountChangePasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(accountChangePasswordRequestModel: AccountChangePasswordRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(accountChangePasswordRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable 2FA after validating the authenticator code
         * @param {AuthenticationTwoFactorVerifyRequestModel} authenticationTwoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableTwoFactor(authenticationTwoFactorVerifyRequestModel: AuthenticationTwoFactorVerifyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableTwoFactor(authenticationTwoFactorVerifyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.disableTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountPutBodyRequestModel} accountPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(accountPutBodyRequestModel: AccountPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(accountPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Confirm the 2FA secret and enable mandatory token checks
         * @param {AuthenticationTwoFactorVerifyRequestModel} authenticationTwoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableTwoFactor(authenticationTwoFactorVerifyRequestModel: AuthenticationTwoFactorVerifyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableTwoFactor(authenticationTwoFactorVerifyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.enableTwoFactor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate a new 2FA secret for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTwoFactorSecret(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTwoFactorGenerateResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTwoFactorSecret(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.generateTwoFactorSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountProfileResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.profile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {AccountApiChangePasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestParameters: AccountApiChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.changePassword(requestParameters.accountChangePasswordRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable 2FA after validating the authenticator code
         * @param {AccountApiDisableTwoFactorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTwoFactor(requestParameters: AccountApiDisableTwoFactorRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.disableTwoFactor(requestParameters.authenticationTwoFactorVerifyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: AccountApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.accountPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm the 2FA secret and enable mandatory token checks
         * @param {AccountApiEnableTwoFactorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTwoFactor(requestParameters: AccountApiEnableTwoFactorRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.enableTwoFactor(requestParameters.authenticationTwoFactorVerifyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a new 2FA secret for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTwoFactorSecret(options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTwoFactorGenerateResponseBaseModel> {
            return localVarFp.generateTwoFactorSecret(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(options?: RawAxiosRequestConfig): AxiosPromise<AccountProfileResponseBaseModel> {
            return localVarFp.profile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePassword operation in AccountApi.
 */
export interface AccountApiChangePasswordRequest {
    readonly accountChangePasswordRequestModel: AccountChangePasswordRequestModel
}

/**
 * Request parameters for disableTwoFactor operation in AccountApi.
 */
export interface AccountApiDisableTwoFactorRequest {
    readonly authenticationTwoFactorVerifyRequestModel: AuthenticationTwoFactorVerifyRequestModel
}

/**
 * Request parameters for edit operation in AccountApi.
 */
export interface AccountApiEditRequest {
    readonly accountPutBodyRequestModel: AccountPutBodyRequestModel
}

/**
 * Request parameters for enableTwoFactor operation in AccountApi.
 */
export interface AccountApiEnableTwoFactorRequest {
    readonly authenticationTwoFactorVerifyRequestModel: AuthenticationTwoFactorVerifyRequestModel
}

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {AccountApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changePassword(requestParameters: AccountApiChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).changePassword(requestParameters.accountChangePasswordRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable 2FA after validating the authenticator code
     * @param {AccountApiDisableTwoFactorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disableTwoFactor(requestParameters: AccountApiDisableTwoFactorRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).disableTwoFactor(requestParameters.authenticationTwoFactorVerifyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: AccountApiEditRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).edit(requestParameters.accountPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm the 2FA secret and enable mandatory token checks
     * @param {AccountApiEnableTwoFactorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enableTwoFactor(requestParameters: AccountApiEnableTwoFactorRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).enableTwoFactor(requestParameters.authenticationTwoFactorVerifyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a new 2FA secret for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateTwoFactorSecret(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).generateTwoFactorSecret(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profile(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).profile(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthenticationSignInRequestModel} authenticationSignInRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (authenticationSignInRequestModel: AuthenticationSignInRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationSignInRequestModel' is not null or undefined
            assertParamExists('login', 'authenticationSignInRequestModel', authenticationSignInRequestModel)
            const localVarPath = `/Api/Authentication/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationSignInRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout and revoke refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationRefreshTokenRequestModel' is not null or undefined
            assertParamExists('logout', 'authenticationRefreshTokenRequestModel', authenticationRefreshTokenRequestModel)
            const localVarPath = `/Api/Authentication/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRefreshTokenRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh access token using refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationRefreshTokenRequestModel' is not null or undefined
            assertParamExists('refreshToken', 'authenticationRefreshTokenRequestModel', authenticationRefreshTokenRequestModel)
            const localVarPath = `/Api/Authentication/RefreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRefreshTokenRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 
         * @param {AuthenticationSignUpRequestModel} authenticationSignUpRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (authenticationSignUpRequestModel: AuthenticationSignUpRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationSignUpRequestModel' is not null or undefined
            assertParamExists('register', 'authenticationSignUpRequestModel', authenticationSignUpRequestModel)
            const localVarPath = `/Api/Authentication/Register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationSignUpRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthenticationResetPasswordRequestModel} authenticationResetPasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (authenticationResetPasswordRequestModel: AuthenticationResetPasswordRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationResetPasswordRequestModel' is not null or undefined
            assertParamExists('resetPassword', 'authenticationResetPasswordRequestModel', authenticationResetPasswordRequestModel)
            const localVarPath = `/Api/Authentication/ResetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationResetPasswordRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether the provided email/password pair is valid and if 2FA applies
         * @param {AuthenticationVerifyCredentialsRequestModel} authenticationVerifyCredentialsRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredentials: async (authenticationVerifyCredentialsRequestModel: AuthenticationVerifyCredentialsRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationVerifyCredentialsRequestModel' is not null or undefined
            assertParamExists('verifyCredentials', 'authenticationVerifyCredentialsRequestModel', authenticationVerifyCredentialsRequestModel)
            const localVarPath = `/Api/Authentication/VerifyCredentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationVerifyCredentialsRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthenticationSignInRequestModel} authenticationSignInRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(authenticationSignInRequestModel: AuthenticationSignInRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(authenticationSignInRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout and revoke refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(authenticationRefreshTokenRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Refresh access token using refresh token
         * @param {AuthenticationRefreshTokenRequestModel} authenticationRefreshTokenRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(authenticationRefreshTokenRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary 
         * @param {AuthenticationSignUpRequestModel} authenticationSignUpRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(authenticationSignUpRequestModel: AuthenticationSignUpRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationTokenResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(authenticationSignUpRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthenticationResetPasswordRequestModel} authenticationResetPasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(authenticationResetPasswordRequestModel: AuthenticationResetPasswordRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(authenticationResetPasswordRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check whether the provided email/password pair is valid and if 2FA applies
         * @param {AuthenticationVerifyCredentialsRequestModel} authenticationVerifyCredentialsRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyCredentials(authenticationVerifyCredentialsRequestModel: AuthenticationVerifyCredentialsRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationVerifyCredentialsResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyCredentials(authenticationVerifyCredentialsRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.verifyCredentials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenResponseBaseModel> {
            return localVarFp.login(requestParameters.authenticationSignInRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout and revoke refresh token
         * @param {AuthenticationApiLogoutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(requestParameters: AuthenticationApiLogoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.logout(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh access token using refresh token
         * @param {AuthenticationApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthenticationApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenResponseBaseModel> {
            return localVarFp.refreshToken(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 
         * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationTokenResponseBaseModel> {
            return localVarFp.register(requestParameters.authenticationSignUpRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.resetPassword(requestParameters.authenticationResetPasswordRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check whether the provided email/password pair is valid and if 2FA applies
         * @param {AuthenticationApiVerifyCredentialsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyCredentials(requestParameters: AuthenticationApiVerifyCredentialsRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationVerifyCredentialsResponseBaseModel> {
            return localVarFp.verifyCredentials(requestParameters.authenticationVerifyCredentialsRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for login operation in AuthenticationApi.
 */
export interface AuthenticationApiLoginRequest {
    readonly authenticationSignInRequestModel: AuthenticationSignInRequestModel
}

/**
 * Request parameters for logout operation in AuthenticationApi.
 */
export interface AuthenticationApiLogoutRequest {
    readonly authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel
}

/**
 * Request parameters for refreshToken operation in AuthenticationApi.
 */
export interface AuthenticationApiRefreshTokenRequest {
    readonly authenticationRefreshTokenRequestModel: AuthenticationRefreshTokenRequestModel
}

/**
 * Request parameters for register operation in AuthenticationApi.
 */
export interface AuthenticationApiRegisterRequest {
    readonly authenticationSignUpRequestModel: AuthenticationSignUpRequestModel
}

/**
 * Request parameters for resetPassword operation in AuthenticationApi.
 */
export interface AuthenticationApiResetPasswordRequest {
    readonly authenticationResetPasswordRequestModel: AuthenticationResetPasswordRequestModel
}

/**
 * Request parameters for verifyCredentials operation in AuthenticationApi.
 */
export interface AuthenticationApiVerifyCredentialsRequest {
    readonly authenticationVerifyCredentialsRequestModel: AuthenticationVerifyCredentialsRequestModel
}

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(requestParameters.authenticationSignInRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout and revoke refresh token
     * @param {AuthenticationApiLogoutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(requestParameters: AuthenticationApiLogoutRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh access token using refresh token
     * @param {AuthenticationApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refreshToken(requestParameters: AuthenticationApiRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshToken(requestParameters.authenticationRefreshTokenRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 
     * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(requestParameters.authenticationSignUpRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPassword(requestParameters.authenticationResetPasswordRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check whether the provided email/password pair is valid and if 2FA applies
     * @param {AuthenticationApiVerifyCredentialsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyCredentials(requestParameters: AuthenticationApiVerifyCredentialsRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verifyCredentials(requestParameters.authenticationVerifyCredentialsRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudApi - axios parameter creator
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes one or more objects (or directories) belonging to the authenticated user.
         * @summary Delete objects
         * @param {CloudDeleteRequestModel} cloudDeleteRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (cloudDeleteRequestModel: CloudDeleteRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudDeleteRequestModel' is not null or undefined
            assertParamExists('_delete', 'cloudDeleteRequestModel', cloudDeleteRequestModel)
            const localVarPath = `/Api/Cloud/Delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudDeleteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
         * @summary Convert a directory to encrypted
         * @param {string} xFolderPassphrase Passphrase for encryption (min 8 chars)
         * @param {DirectoryConvertToEncryptedRequestModel} directoryConvertToEncryptedRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryConvertToEncrypted: async (xFolderPassphrase: string, directoryConvertToEncryptedRequestModel: DirectoryConvertToEncryptedRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xFolderPassphrase' is not null or undefined
            assertParamExists('directoryConvertToEncrypted', 'xFolderPassphrase', xFolderPassphrase)
            // verify required parameter 'directoryConvertToEncryptedRequestModel' is not null or undefined
            assertParamExists('directoryConvertToEncrypted', 'directoryConvertToEncryptedRequestModel', directoryConvertToEncryptedRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Encrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryConvertToEncryptedRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
         * @summary Create a directory
         * @param {DirectoryCreateRequestModel} directoryCreateRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory (min 8 chars)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCreate: async (directoryCreateRequestModel: DirectoryCreateRequestModel, xFolderPassphrase?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryCreateRequestModel' is not null or undefined
            assertParamExists('directoryCreate', 'directoryCreateRequestModel', directoryCreateRequestModel)
            const localVarPath = `/Api/Cloud/Directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryCreateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
         * @summary Remove encryption from a directory
         * @param {string} xFolderPassphrase Passphrase for decryption
         * @param {DirectoryDecryptRequestModel} directoryDecryptRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDecrypt: async (xFolderPassphrase: string, directoryDecryptRequestModel: DirectoryDecryptRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xFolderPassphrase' is not null or undefined
            assertParamExists('directoryDecrypt', 'xFolderPassphrase', xFolderPassphrase)
            // verify required parameter 'directoryDecryptRequestModel' is not null or undefined
            assertParamExists('directoryDecrypt', 'directoryDecryptRequestModel', directoryDecryptRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Decrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryDecryptRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Delete a directory
         * @param {DirectoryDeleteRequestModel} directoryDeleteRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDelete: async (directoryDeleteRequestModel: DirectoryDeleteRequestModel, xFolderPassphrase?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryDeleteRequestModel' is not null or undefined
            assertParamExists('directoryDelete', 'directoryDeleteRequestModel', directoryDeleteRequestModel)
            const localVarPath = `/Api/Cloud/Directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryDeleteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the session token for an encrypted directory.
         * @summary Lock an encrypted directory
         * @param {DirectoryLockRequestModel} directoryLockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryLock: async (directoryLockRequestModel: DirectoryLockRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryLockRequestModel' is not null or undefined
            assertParamExists('directoryLock', 'directoryLockRequestModel', directoryLockRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Lock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryLockRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Rename a directory
         * @param {DirectoryRenameRequestModel} directoryRenameRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryRename: async (directoryRenameRequestModel: DirectoryRenameRequestModel, xFolderPassphrase?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryRenameRequestModel' is not null or undefined
            assertParamExists('directoryRename', 'directoryRenameRequestModel', directoryRenameRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryRenameRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
         * @summary Unlock an encrypted directory
         * @param {string} xFolderPassphrase Passphrase for encrypted directory (min 8 chars)
         * @param {DirectoryUnlockRequestModel} directoryUnlockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryUnlock: async (xFolderPassphrase: string, directoryUnlockRequestModel: DirectoryUnlockRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xFolderPassphrase' is not null or undefined
            assertParamExists('directoryUnlock', 'xFolderPassphrase', xFolderPassphrase)
            // verify required parameter 'directoryUnlockRequestModel' is not null or undefined
            assertParamExists('directoryUnlock', 'directoryUnlockRequestModel', directoryUnlockRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Unlock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryUnlockRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
         * @summary Download a file for the authenticated user (streamed)
         * @param {string} key Path/key to the file (user-scoped)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('download', 'key', key)
            const localVarPath = `/Api/Cloud/Download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a single object by key (user scoped) and return its metadata.
         * @summary Get object metadata
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('find', 'key', key)
            const localVarPath = `/Api/Cloud/Find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a presigned URL for a specific object key to allow direct client access.
         * @summary Get a presigned URL for upload/download
         * @param {string} key 
         * @param {number} [expiresInSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrl: async (key: string, expiresInSeconds?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPresignedUrl', 'key', key)
            const localVarPath = `/Api/Cloud/PresignedUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }

            if (expiresInSeconds !== undefined) {
                localVarQueryParameter['ExpiresInSeconds'] = expiresInSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List files and directories
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }

            if (isMetadataProcessing !== undefined) {
                localVarQueryParameter['IsMetadataProcessing'] = isMetadataProcessing;
            }


    
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns breadcrumb entries (path pieces) for the supplied path.
         * @summary Get breadcrumb for a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBreadcrumb: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List/Breadcrumb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List directories inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDirectories: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List/Directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }


    
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List objects (files) inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List/Objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }

            if (isMetadataProcessing !== undefined) {
                localVarQueryParameter['IsMetadataProcessing'] = isMetadataProcessing;
            }


    
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move an object from SourceKey to DestinationKey within the user scope.
         * @summary Move/rename an object
         * @param {CloudMoveRequestModel} cloudMoveRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move: async (cloudMoveRequestModel: CloudMoveRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudMoveRequestModel' is not null or undefined
            assertParamExists('move', 'cloudMoveRequestModel', cloudMoveRequestModel)
            const localVarPath = `/Api/Cloud/Move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudMoveRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing object by changing metadata or renaming the file (name only).
         * @summary Update object metadata or rename
         * @param {CloudUpdateRequestModel} cloudUpdateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (cloudUpdateRequestModel: CloudUpdateRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudUpdateRequestModel' is not null or undefined
            assertParamExists('update', 'cloudUpdateRequestModel', cloudUpdateRequestModel)
            const localVarPath = `/Api/Cloud/Update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudUpdateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Abort an ongoing multipart upload and clean up temporary state.
         * @summary Abort a multipart upload
         * @param {CloudAbortMultipartUploadRequestModel} cloudAbortMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAbortMultipartUpload: async (cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudAbortMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadAbortMultipartUpload', 'cloudAbortMultipartUploadRequestModel', cloudAbortMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/AbortMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudAbortMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a multipart upload by providing the list of parts and finalizes the object.
         * @summary Complete multipart upload
         * @param {CloudCompleteMultipartUploadRequestModel} cloudCompleteMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompleteMultipartUpload: async (cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudCompleteMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadCompleteMultipartUpload', 'cloudCompleteMultipartUploadRequestModel', cloudCompleteMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/CompleteMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudCompleteMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an UploadId and starts a multipart upload flow.
         * @summary Create a multipart upload session
         * @param {CloudCreateMultipartUploadRequestModel} cloudCreateMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCreateMultipartUpload: async (cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudCreateMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadCreateMultipartUpload', 'cloudCreateMultipartUploadRequestModel', cloudCreateMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/CreateMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudCreateMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
         * @summary Get a multipart upload part URL
         * @param {CloudGetMultipartPartUrlRequestModel} cloudGetMultipartPartUrlRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGetMultipartPartUrl: async (cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudGetMultipartPartUrlRequestModel' is not null or undefined
            assertParamExists('uploadGetMultipartPartUrl', 'cloudGetMultipartPartUrlRequestModel', cloudGetMultipartPartUrlRequestModel)
            const localVarPath = `/Api/Cloud/Upload/GetMultipartPartUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudGetMultipartPartUrlRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
         * @summary Upload a multipart part
         * @param {string} key 
         * @param {string} uploadId 
         * @param {number} partNumber 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart: async (key: string, uploadId: string, partNumber: number, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('uploadPart', 'key', key)
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('uploadPart', 'uploadId', uploadId)
            // verify required parameter 'partNumber' is not null or undefined
            assertParamExists('uploadPart', 'partNumber', partNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadPart', 'file', file)
            const localVarPath = `/Api/Cloud/Upload/UploadPart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (key !== undefined) { 
                localVarFormParams.append('Key', key as any);
            }
    
            if (uploadId !== undefined) { 
                localVarFormParams.append('UploadId', uploadId as any);
            }
    
            if (partNumber !== undefined) { 
                localVarFormParams.append('PartNumber', partNumber as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the authenticated user storage usage and limits.
         * @summary Get user\'s storage usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStorageUsage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/User/StorageUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes one or more objects (or directories) belonging to the authenticated user.
         * @summary Delete objects
         * @param {CloudDeleteRequestModel} cloudDeleteRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(cloudDeleteRequestModel: CloudDeleteRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(cloudDeleteRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
         * @summary Convert a directory to encrypted
         * @param {string} xFolderPassphrase Passphrase for encryption (min 8 chars)
         * @param {DirectoryConvertToEncryptedRequestModel} directoryConvertToEncryptedRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryConvertToEncrypted(xFolderPassphrase: string, directoryConvertToEncryptedRequestModel: DirectoryConvertToEncryptedRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryConvertToEncrypted(xFolderPassphrase, directoryConvertToEncryptedRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryConvertToEncrypted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
         * @summary Create a directory
         * @param {DirectoryCreateRequestModel} directoryCreateRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory (min 8 chars)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryCreate(directoryCreateRequestModel: DirectoryCreateRequestModel, xFolderPassphrase?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryCreate(directoryCreateRequestModel, xFolderPassphrase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
         * @summary Remove encryption from a directory
         * @param {string} xFolderPassphrase Passphrase for decryption
         * @param {DirectoryDecryptRequestModel} directoryDecryptRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryDecrypt(xFolderPassphrase: string, directoryDecryptRequestModel: DirectoryDecryptRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryDecrypt(xFolderPassphrase, directoryDecryptRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryDecrypt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Delete a directory
         * @param {DirectoryDeleteRequestModel} directoryDeleteRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryDelete(directoryDeleteRequestModel: DirectoryDeleteRequestModel, xFolderPassphrase?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryDelete(directoryDeleteRequestModel, xFolderPassphrase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates the session token for an encrypted directory.
         * @summary Lock an encrypted directory
         * @param {DirectoryLockRequestModel} directoryLockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryLock(directoryLockRequestModel: DirectoryLockRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryLock(directoryLockRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryLock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Rename a directory
         * @param {DirectoryRenameRequestModel} directoryRenameRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryRename(directoryRenameRequestModel: DirectoryRenameRequestModel, xFolderPassphrase?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryRename(directoryRenameRequestModel, xFolderPassphrase, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryRename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
         * @summary Unlock an encrypted directory
         * @param {string} xFolderPassphrase Passphrase for encrypted directory (min 8 chars)
         * @param {DirectoryUnlockRequestModel} directoryUnlockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryUnlock(xFolderPassphrase: string, directoryUnlockRequestModel: DirectoryUnlockRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryUnlockResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryUnlock(xFolderPassphrase, directoryUnlockRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryUnlock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
         * @summary Download a file for the authenticated user (streamed)
         * @param {string} key Path/key to the file (user-scoped)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.download']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find a single object by key (user scoped) and return its metadata.
         * @summary Get object metadata
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a presigned URL for a specific object key to allow direct client access.
         * @summary Get a presigned URL for upload/download
         * @param {string} key 
         * @param {number} [expiresInSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrl(key: string, expiresInSeconds?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrl(key, expiresInSeconds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getPresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List files and directories
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudListResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(search, skip, take, path, delimiter, isMetadataProcessing, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns breadcrumb entries (path pieces) for the supplied path.
         * @summary Get breadcrumb for a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBreadcrumb(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudBreadCrumbListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBreadcrumb(search, skip, take, path, delimiter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listBreadcrumb']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List directories inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDirectories(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudDirectoryListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDirectories(search, skip, take, path, delimiter, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listDirectories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List objects (files) inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObjects(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudObjectListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listObjects(search, skip, take, path, delimiter, isMetadataProcessing, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move an object from SourceKey to DestinationKey within the user scope.
         * @summary Move/rename an object
         * @param {CloudMoveRequestModel} cloudMoveRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async move(cloudMoveRequestModel: CloudMoveRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(cloudMoveRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.move']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing object by changing metadata or renaming the file (name only).
         * @summary Update object metadata or rename
         * @param {CloudUpdateRequestModel} cloudUpdateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(cloudUpdateRequestModel: CloudUpdateRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudObjectBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(cloudUpdateRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Abort an ongoing multipart upload and clean up temporary state.
         * @summary Abort a multipart upload
         * @param {CloudAbortMultipartUploadRequestModel} cloudAbortMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAbortMultipartUpload(cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAbortMultipartUpload(cloudAbortMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadAbortMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes a multipart upload by providing the list of parts and finalizes the object.
         * @summary Complete multipart upload
         * @param {CloudCompleteMultipartUploadRequestModel} cloudCompleteMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCompleteMultipartUpload(cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudCompleteMultipartUploadResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCompleteMultipartUpload(cloudCompleteMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadCompleteMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an UploadId and starts a multipart upload flow.
         * @summary Create a multipart upload session
         * @param {CloudCreateMultipartUploadRequestModel} cloudCreateMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCreateMultipartUpload(cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudCreateMultipartUploadResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCreateMultipartUpload(cloudCreateMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadCreateMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
         * @summary Get a multipart upload part URL
         * @param {CloudGetMultipartPartUrlRequestModel} cloudGetMultipartPartUrlRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGetMultipartPartUrl(cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudGetMultipartPartUrlResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGetMultipartPartUrl(cloudGetMultipartPartUrlRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadGetMultipartPartUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
         * @summary Upload a multipart part
         * @param {string} key 
         * @param {string} uploadId 
         * @param {number} partNumber 
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPart(key: string, uploadId: string, partNumber: number, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUploadPartResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPart(key, uploadId, partNumber, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the authenticated user storage usage and limits.
         * @summary Get user\'s storage usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userStorageUsage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUserStorageUsageResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userStorageUsage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.userStorageUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudApi - factory interface
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Deletes one or more objects (or directories) belonging to the authenticated user.
         * @summary Delete objects
         * @param {CloudApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: CloudApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp._delete(requestParameters.cloudDeleteRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
         * @summary Convert a directory to encrypted
         * @param {CloudApiDirectoryConvertToEncryptedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryConvertToEncrypted(requestParameters: CloudApiDirectoryConvertToEncryptedRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryConvertToEncrypted(requestParameters.xFolderPassphrase, requestParameters.directoryConvertToEncryptedRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
         * @summary Create a directory
         * @param {CloudApiDirectoryCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCreate(requestParameters: CloudApiDirectoryCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryCreate(requestParameters.directoryCreateRequestModel, requestParameters.xFolderPassphrase, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
         * @summary Remove encryption from a directory
         * @param {CloudApiDirectoryDecryptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDecrypt(requestParameters: CloudApiDirectoryDecryptRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryDecrypt(requestParameters.xFolderPassphrase, requestParameters.directoryDecryptRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Delete a directory
         * @param {CloudApiDirectoryDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDelete(requestParameters: CloudApiDirectoryDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.directoryDelete(requestParameters.directoryDeleteRequestModel, requestParameters.xFolderPassphrase, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the session token for an encrypted directory.
         * @summary Lock an encrypted directory
         * @param {CloudApiDirectoryLockRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryLock(requestParameters: CloudApiDirectoryLockRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.directoryLock(requestParameters.directoryLockRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Rename a directory
         * @param {CloudApiDirectoryRenameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryRename(requestParameters: CloudApiDirectoryRenameRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryRename(requestParameters.directoryRenameRequestModel, requestParameters.xFolderPassphrase, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
         * @summary Unlock an encrypted directory
         * @param {CloudApiDirectoryUnlockRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryUnlock(requestParameters: CloudApiDirectoryUnlockRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryUnlockResponseBaseModel> {
            return localVarFp.directoryUnlock(requestParameters.xFolderPassphrase, requestParameters.directoryUnlockRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
         * @summary Download a file for the authenticated user (streamed)
         * @param {CloudApiDownloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(requestParameters: CloudApiDownloadRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.download(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a single object by key (user scoped) and return its metadata.
         * @summary Get object metadata
         * @param {CloudApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: CloudApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.find(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a presigned URL for a specific object key to allow direct client access.
         * @summary Get a presigned URL for upload/download
         * @param {CloudApiGetPresignedUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrl(requestParameters: CloudApiGetPresignedUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<StringResponseModel> {
            return localVarFp.getPresignedUrl(requestParameters.key, requestParameters.expiresInSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List files and directories
         * @param {CloudApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: CloudApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudListResponseBaseModel> {
            return localVarFp.list(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns breadcrumb entries (path pieces) for the supplied path.
         * @summary Get breadcrumb for a path
         * @param {CloudApiListBreadcrumbRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBreadcrumb(requestParameters: CloudApiListBreadcrumbRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudBreadCrumbListBaseModel> {
            return localVarFp.listBreadcrumb(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List directories inside a path
         * @param {CloudApiListDirectoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDirectories(requestParameters: CloudApiListDirectoriesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudDirectoryListBaseModel> {
            return localVarFp.listDirectories(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List objects (files) inside a path
         * @param {CloudApiListObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects(requestParameters: CloudApiListObjectsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudObjectListBaseModel> {
            return localVarFp.listObjects(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Move an object from SourceKey to DestinationKey within the user scope.
         * @summary Move/rename an object
         * @param {CloudApiMoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(requestParameters: CloudApiMoveRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.move(requestParameters.cloudMoveRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing object by changing metadata or renaming the file (name only).
         * @summary Update object metadata or rename
         * @param {CloudApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: CloudApiUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudObjectBaseModel> {
            return localVarFp.update(requestParameters.cloudUpdateRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Abort an ongoing multipart upload and clean up temporary state.
         * @summary Abort a multipart upload
         * @param {CloudApiUploadAbortMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAbortMultipartUpload(requestParameters: CloudApiUploadAbortMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadAbortMultipartUpload(requestParameters.cloudAbortMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a multipart upload by providing the list of parts and finalizes the object.
         * @summary Complete multipart upload
         * @param {CloudApiUploadCompleteMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompleteMultipartUpload(requestParameters: CloudApiUploadCompleteMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudCompleteMultipartUploadResponseBaseModel> {
            return localVarFp.uploadCompleteMultipartUpload(requestParameters.cloudCompleteMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an UploadId and starts a multipart upload flow.
         * @summary Create a multipart upload session
         * @param {CloudApiUploadCreateMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCreateMultipartUpload(requestParameters: CloudApiUploadCreateMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudCreateMultipartUploadResponseBaseModel> {
            return localVarFp.uploadCreateMultipartUpload(requestParameters.cloudCreateMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
         * @summary Get a multipart upload part URL
         * @param {CloudApiUploadGetMultipartPartUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGetMultipartPartUrl(requestParameters: CloudApiUploadGetMultipartPartUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudGetMultipartPartUrlResponseBaseModel> {
            return localVarFp.uploadGetMultipartPartUrl(requestParameters.cloudGetMultipartPartUrlRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
         * @summary Upload a multipart part
         * @param {CloudApiUploadPartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(requestParameters: CloudApiUploadPartRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudUploadPartResponseBaseModel> {
            return localVarFp.uploadPart(requestParameters.key, requestParameters.uploadId, requestParameters.partNumber, requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the authenticated user storage usage and limits.
         * @summary Get user\'s storage usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStorageUsage(options?: RawAxiosRequestConfig): AxiosPromise<CloudUserStorageUsageResponseBaseModel> {
            return localVarFp.userStorageUsage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in CloudApi.
 */
export interface CloudApiDeleteRequest {
    readonly cloudDeleteRequestModel: CloudDeleteRequestModel
}

/**
 * Request parameters for directoryConvertToEncrypted operation in CloudApi.
 */
export interface CloudApiDirectoryConvertToEncryptedRequest {
    /**
     * Passphrase for encryption (min 8 chars)
     */
    readonly xFolderPassphrase: string

    readonly directoryConvertToEncryptedRequestModel: DirectoryConvertToEncryptedRequestModel
}

/**
 * Request parameters for directoryCreate operation in CloudApi.
 */
export interface CloudApiDirectoryCreateRequest {
    readonly directoryCreateRequestModel: DirectoryCreateRequestModel

    /**
     * Passphrase for encrypted directory (min 8 chars)
     */
    readonly xFolderPassphrase?: string
}

/**
 * Request parameters for directoryDecrypt operation in CloudApi.
 */
export interface CloudApiDirectoryDecryptRequest {
    /**
     * Passphrase for decryption
     */
    readonly xFolderPassphrase: string

    readonly directoryDecryptRequestModel: DirectoryDecryptRequestModel
}

/**
 * Request parameters for directoryDelete operation in CloudApi.
 */
export interface CloudApiDirectoryDeleteRequest {
    readonly directoryDeleteRequestModel: DirectoryDeleteRequestModel

    /**
     * Passphrase for encrypted directory
     */
    readonly xFolderPassphrase?: string
}

/**
 * Request parameters for directoryLock operation in CloudApi.
 */
export interface CloudApiDirectoryLockRequest {
    readonly directoryLockRequestModel: DirectoryLockRequestModel
}

/**
 * Request parameters for directoryRename operation in CloudApi.
 */
export interface CloudApiDirectoryRenameRequest {
    readonly directoryRenameRequestModel: DirectoryRenameRequestModel

    /**
     * Passphrase for encrypted directory
     */
    readonly xFolderPassphrase?: string
}

/**
 * Request parameters for directoryUnlock operation in CloudApi.
 */
export interface CloudApiDirectoryUnlockRequest {
    /**
     * Passphrase for encrypted directory (min 8 chars)
     */
    readonly xFolderPassphrase: string

    readonly directoryUnlockRequestModel: DirectoryUnlockRequestModel
}

/**
 * Request parameters for download operation in CloudApi.
 */
export interface CloudApiDownloadRequest {
    /**
     * Path/key to the file (user-scoped)
     */
    readonly key: string
}

/**
 * Request parameters for find operation in CloudApi.
 */
export interface CloudApiFindRequest {
    readonly key: string
}

/**
 * Request parameters for getPresignedUrl operation in CloudApi.
 */
export interface CloudApiGetPresignedUrlRequest {
    readonly key: string

    readonly expiresInSeconds?: number
}

/**
 * Request parameters for list operation in CloudApi.
 */
export interface CloudApiListRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean

    readonly isMetadataProcessing?: boolean

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for listBreadcrumb operation in CloudApi.
 */
export interface CloudApiListBreadcrumbRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean
}

/**
 * Request parameters for listDirectories operation in CloudApi.
 */
export interface CloudApiListDirectoriesRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for listObjects operation in CloudApi.
 */
export interface CloudApiListObjectsRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean

    readonly isMetadataProcessing?: boolean

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for move operation in CloudApi.
 */
export interface CloudApiMoveRequest {
    readonly cloudMoveRequestModel: CloudMoveRequestModel
}

/**
 * Request parameters for update operation in CloudApi.
 */
export interface CloudApiUpdateRequest {
    readonly cloudUpdateRequestModel: CloudUpdateRequestModel
}

/**
 * Request parameters for uploadAbortMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadAbortMultipartUploadRequest {
    readonly cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel
}

/**
 * Request parameters for uploadCompleteMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadCompleteMultipartUploadRequest {
    readonly cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel
}

/**
 * Request parameters for uploadCreateMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadCreateMultipartUploadRequest {
    readonly cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel
}

/**
 * Request parameters for uploadGetMultipartPartUrl operation in CloudApi.
 */
export interface CloudApiUploadGetMultipartPartUrlRequest {
    readonly cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel
}

/**
 * Request parameters for uploadPart operation in CloudApi.
 */
export interface CloudApiUploadPartRequest {
    readonly key: string

    readonly uploadId: string

    readonly partNumber: number

    readonly file: File
}

/**
 * CloudApi - object-oriented interface
 */
export class CloudApi extends BaseAPI {
    /**
     * Deletes one or more objects (or directories) belonging to the authenticated user.
     * @summary Delete objects
     * @param {CloudApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: CloudApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration)._delete(requestParameters.cloudDeleteRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
     * @summary Convert a directory to encrypted
     * @param {CloudApiDirectoryConvertToEncryptedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryConvertToEncrypted(requestParameters: CloudApiDirectoryConvertToEncryptedRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryConvertToEncrypted(requestParameters.xFolderPassphrase, requestParameters.directoryConvertToEncryptedRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
     * @summary Create a directory
     * @param {CloudApiDirectoryCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryCreate(requestParameters: CloudApiDirectoryCreateRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryCreate(requestParameters.directoryCreateRequestModel, requestParameters.xFolderPassphrase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
     * @summary Remove encryption from a directory
     * @param {CloudApiDirectoryDecryptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryDecrypt(requestParameters: CloudApiDirectoryDecryptRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryDecrypt(requestParameters.xFolderPassphrase, requestParameters.directoryDecryptRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
     * @summary Delete a directory
     * @param {CloudApiDirectoryDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryDelete(requestParameters: CloudApiDirectoryDeleteRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryDelete(requestParameters.directoryDeleteRequestModel, requestParameters.xFolderPassphrase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the session token for an encrypted directory.
     * @summary Lock an encrypted directory
     * @param {CloudApiDirectoryLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryLock(requestParameters: CloudApiDirectoryLockRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryLock(requestParameters.directoryLockRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
     * @summary Rename a directory
     * @param {CloudApiDirectoryRenameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryRename(requestParameters: CloudApiDirectoryRenameRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryRename(requestParameters.directoryRenameRequestModel, requestParameters.xFolderPassphrase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
     * @summary Unlock an encrypted directory
     * @param {CloudApiDirectoryUnlockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryUnlock(requestParameters: CloudApiDirectoryUnlockRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryUnlock(requestParameters.xFolderPassphrase, requestParameters.directoryUnlockRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
     * @summary Download a file for the authenticated user (streamed)
     * @param {CloudApiDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public download(requestParameters: CloudApiDownloadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).download(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a single object by key (user scoped) and return its metadata.
     * @summary Get object metadata
     * @param {CloudApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: CloudApiFindRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).find(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a presigned URL for a specific object key to allow direct client access.
     * @summary Get a presigned URL for upload/download
     * @param {CloudApiGetPresignedUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPresignedUrl(requestParameters: CloudApiGetPresignedUrlRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getPresignedUrl(requestParameters.key, requestParameters.expiresInSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
     * @summary List files and directories
     * @param {CloudApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: CloudApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).list(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns breadcrumb entries (path pieces) for the supplied path.
     * @summary Get breadcrumb for a path
     * @param {CloudApiListBreadcrumbRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBreadcrumb(requestParameters: CloudApiListBreadcrumbRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listBreadcrumb(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
     * @summary List directories inside a path
     * @param {CloudApiListDirectoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDirectories(requestParameters: CloudApiListDirectoriesRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listDirectories(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
     * @summary List objects (files) inside a path
     * @param {CloudApiListObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listObjects(requestParameters: CloudApiListObjectsRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listObjects(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move an object from SourceKey to DestinationKey within the user scope.
     * @summary Move/rename an object
     * @param {CloudApiMoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public move(requestParameters: CloudApiMoveRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).move(requestParameters.cloudMoveRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing object by changing metadata or renaming the file (name only).
     * @summary Update object metadata or rename
     * @param {CloudApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: CloudApiUpdateRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).update(requestParameters.cloudUpdateRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Abort an ongoing multipart upload and clean up temporary state.
     * @summary Abort a multipart upload
     * @param {CloudApiUploadAbortMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadAbortMultipartUpload(requestParameters: CloudApiUploadAbortMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadAbortMultipartUpload(requestParameters.cloudAbortMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a multipart upload by providing the list of parts and finalizes the object.
     * @summary Complete multipart upload
     * @param {CloudApiUploadCompleteMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadCompleteMultipartUpload(requestParameters: CloudApiUploadCompleteMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadCompleteMultipartUpload(requestParameters.cloudCompleteMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an UploadId and starts a multipart upload flow.
     * @summary Create a multipart upload session
     * @param {CloudApiUploadCreateMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadCreateMultipartUpload(requestParameters: CloudApiUploadCreateMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadCreateMultipartUpload(requestParameters.cloudCreateMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
     * @summary Get a multipart upload part URL
     * @param {CloudApiUploadGetMultipartPartUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadGetMultipartPartUrl(requestParameters: CloudApiUploadGetMultipartPartUrlRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadGetMultipartPartUrl(requestParameters.cloudGetMultipartPartUrlRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
     * @summary Upload a multipart part
     * @param {CloudApiUploadPartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadPart(requestParameters: CloudApiUploadPartRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadPart(requestParameters.key, requestParameters.uploadId, requestParameters.partNumber, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the authenticated user storage usage and limits.
     * @summary Get user\'s storage usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userStorageUsage(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).userStorageUsage(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefinitionApi - axios parameter creator
 */
export const DefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDefinition: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Find/{groupCode}/{code}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Group/Find/{groupCode}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupCode 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefinition: async (groupCode: string, search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupCode' is not null or undefined
            assertParamExists('listDefinition', 'groupCode', groupCode)
            const localVarPath = `/Api/Definition/List/{groupCode}`
                .replace(`{${"groupCode"}}`, encodeURIComponent(String(groupCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async (search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Group/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefinitionApi - functional programming interface
 */
export const DefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDefinition(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDefinition(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.findDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.findGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupCode 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDefinition(groupCode: string, search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDefinition(groupCode, search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.listDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup(search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefinitionGroupResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup(search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.listGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefinitionApi - factory interface
 */
export const DefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefinitionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDefinition(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findDefinition(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefinitionApiListDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefinition(requestParameters: DefinitionApiListDefinitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listDefinition(requestParameters.groupCode, requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefinitionApiListGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(requestParameters: DefinitionApiListGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DefinitionGroupResponseListBaseModel> {
            return localVarFp.listGroup(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listDefinition operation in DefinitionApi.
 */
export interface DefinitionApiListDefinitionRequest {
    readonly groupCode: string

    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * Request parameters for listGroup operation in DefinitionApi.
 */
export interface DefinitionApiListGroupRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * DefinitionApi - object-oriented interface
 */
export class DefinitionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findDefinition(options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).findDefinition(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findGroup(options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).findGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefinitionApiListDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDefinition(requestParameters: DefinitionApiListDefinitionRequest, options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).listDefinition(requestParameters.groupCode, requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefinitionApiListGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGroup(requestParameters: DefinitionApiListGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).listGroup(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async check(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.check(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.check']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check(options?: RawAxiosRequestConfig): AxiosPromise<Check200Response> {
            return localVarFp.check(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public check(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).check(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HomeApi - axios parameter creator
 */
export const HomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeApi - functional programming interface
 */
export const HomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async home(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.home(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeApi.home']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HomeApi - factory interface
 */
export const HomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home(options?: RawAxiosRequestConfig): AxiosPromise<StringResponseModel> {
            return localVarFp.home(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeApi - object-oriented interface
 */
export class HomeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public home(options?: RawAxiosRequestConfig) {
        return HomeApiFp(this.configuration).home(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionApi - axios parameter creator
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/Api/Subscription/Delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeAsAdminRequestModel} subscribeAsAdminRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign: async (subscribeAsAdminRequestModel: SubscribeAsAdminRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeAsAdminRequestModel' is not null or undefined
            assertParamExists('assign', 'subscribeAsAdminRequestModel', subscribeAsAdminRequestModel)
            const localVarPath = `/Api/Subscription/Assign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeAsAdminRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionPostBodyRequestModel} subscriptionPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (subscriptionPostBodyRequestModel: SubscriptionPostBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionPostBodyRequestModel' is not null or undefined
            assertParamExists('create', 'subscriptionPostBodyRequestModel', subscriptionPostBodyRequestModel)
            const localVarPath = `/Api/Subscription/Create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPostBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SubscriptionPutBodyRequestModel} subscriptionPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (id: string, subscriptionPutBodyRequestModel: SubscriptionPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edit', 'id', id)
            // verify required parameter 'subscriptionPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'subscriptionPutBodyRequestModel', subscriptionPutBodyRequestModel)
            const localVarPath = `/Api/Subscription/Edit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('find', 'id', id)
            const localVarPath = `/Api/Subscription/Find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Subscription/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listForUser', 'id', id)
            const localVarPath = `/Api/Subscription/List/User/{userId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMy: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Subscription/My/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        my: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Subscription/My`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeRequestModel} subscribeRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe: async (subscribeRequestModel: SubscribeRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequestModel' is not null or undefined
            assertParamExists('subscribe', 'subscribeRequestModel', subscribeRequestModel)
            const localVarPath = `/Api/Subscription/My/Subscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribe', 'id', id)
            const localVarPath = `/Api/Subscription/Unsubscribe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe_1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribe_1', 'id', id)
            const localVarPath = `/Api/Subscription/My/Unsubscribe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeAsAdminRequestModel} subscribeAsAdminRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assign(subscribeAsAdminRequestModel: SubscribeAsAdminRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assign(subscribeAsAdminRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.assign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscriptionPostBodyRequestModel} subscriptionPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(subscriptionPostBodyRequestModel: SubscriptionPostBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(subscriptionPostBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SubscriptionPutBodyRequestModel} subscriptionPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(id: string, subscriptionPutBodyRequestModel: SubscriptionPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(id, subscriptionPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionFindResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionListResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSubscriptionResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.listForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMy(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMy(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.listMy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async my(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.my(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.my']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeRequestModel} subscribeRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribe(subscribeRequestModel: SubscribeRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribe(subscribeRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.subscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.unsubscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe_1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe_1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.unsubscribe_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @param {SubscriptionApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: SubscriptionApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp._delete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiAssignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign(requestParameters: SubscriptionApiAssignRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.assign(requestParameters.subscribeAsAdminRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: SubscriptionApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.create(requestParameters.subscriptionPostBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: SubscriptionApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.id, requestParameters.subscriptionPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: SubscriptionApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionFindResponseBaseModel> {
            return localVarFp.find(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionListResponseListBaseModel> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiListForUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForUser(requestParameters: SubscriptionApiListForUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserSubscriptionResponseListBaseModel> {
            return localVarFp.listForUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMy(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listMy(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        my(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.my(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiSubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe(requestParameters: SubscriptionApiSubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscribe(requestParameters.subscribeRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiUnsubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe(requestParameters: SubscriptionApiUnsubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.unsubscribe(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiUnsubscribe0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe_1(requestParameters: SubscriptionApiUnsubscribe0Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unsubscribe_1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in SubscriptionApi.
 */
export interface SubscriptionApiDeleteRequest {
    readonly id: string
}

/**
 * Request parameters for assign operation in SubscriptionApi.
 */
export interface SubscriptionApiAssignRequest {
    readonly subscribeAsAdminRequestModel: SubscribeAsAdminRequestModel
}

/**
 * Request parameters for create operation in SubscriptionApi.
 */
export interface SubscriptionApiCreateRequest {
    readonly subscriptionPostBodyRequestModel: SubscriptionPostBodyRequestModel
}

/**
 * Request parameters for edit operation in SubscriptionApi.
 */
export interface SubscriptionApiEditRequest {
    readonly id: string

    readonly subscriptionPutBodyRequestModel: SubscriptionPutBodyRequestModel
}

/**
 * Request parameters for find operation in SubscriptionApi.
 */
export interface SubscriptionApiFindRequest {
    readonly id: string
}

/**
 * Request parameters for listForUser operation in SubscriptionApi.
 */
export interface SubscriptionApiListForUserRequest {
    readonly id: string
}

/**
 * Request parameters for subscribe operation in SubscriptionApi.
 */
export interface SubscriptionApiSubscribeRequest {
    readonly subscribeRequestModel: SubscribeRequestModel
}

/**
 * Request parameters for unsubscribe operation in SubscriptionApi.
 */
export interface SubscriptionApiUnsubscribeRequest {
    readonly id: string
}

/**
 * Request parameters for unsubscribe_1 operation in SubscriptionApi.
 */
export interface SubscriptionApiUnsubscribe0Request {
    readonly id: string
}

/**
 * SubscriptionApi - object-oriented interface
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {SubscriptionApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: SubscriptionApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiAssignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public assign(requestParameters: SubscriptionApiAssignRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).assign(requestParameters.subscribeAsAdminRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: SubscriptionApiCreateRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).create(requestParameters.subscriptionPostBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: SubscriptionApiEditRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).edit(requestParameters.id, requestParameters.subscriptionPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: SubscriptionApiFindRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).find(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiListForUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listForUser(requestParameters: SubscriptionApiListForUserRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).listForUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listMy(options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).listMy(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public my(options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).my(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiSubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public subscribe(requestParameters: SubscriptionApiSubscribeRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).subscribe(requestParameters.subscribeRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsubscribe(requestParameters: SubscriptionApiUnsubscribeRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).unsubscribe(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiUnsubscribe0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsubscribe_1(requestParameters: SubscriptionApiUnsubscribe0Request, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).unsubscribe_1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/Api/User/Delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserPostBodyRequestModel} userPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (userPostBodyRequestModel: UserPostBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPostBodyRequestModel' is not null or undefined
            assertParamExists('create', 'userPostBodyRequestModel', userPostBodyRequestModel)
            const localVarPath = `/Api/User/Create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPostBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserPutBodyRequestModel} userPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (id: string, userPutBodyRequestModel: UserPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edit', 'id', id)
            // verify required parameter 'userPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'userPutBodyRequestModel', userPutBodyRequestModel)
            const localVarPath = `/Api/User/Edit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('find', 'id', id)
            const localVarPath = `/Api/User/Find/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/User/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserPostBodyRequestModel} userPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(userPostBodyRequestModel: UserPostBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(userPostBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UserPutBodyRequestModel} userPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(id: string, userPutBodyRequestModel: UserPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(id, userPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFindResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {UserApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: UserApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp._delete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: UserApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.create(requestParameters.userPostBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: UserApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.id, requestParameters.userPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: UserApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserFindResponseBaseModel> {
            return localVarFp.find(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: UserApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponseListBaseModel> {
            return localVarFp.list(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in UserApi.
 */
export interface UserApiDeleteRequest {
    readonly id: string
}

/**
 * Request parameters for create operation in UserApi.
 */
export interface UserApiCreateRequest {
    readonly userPostBodyRequestModel: UserPostBodyRequestModel
}

/**
 * Request parameters for edit operation in UserApi.
 */
export interface UserApiEditRequest {
    readonly id: string

    readonly userPutBodyRequestModel: UserPutBodyRequestModel
}

/**
 * Request parameters for find operation in UserApi.
 */
export interface UserApiFindRequest {
    readonly id: string
}

/**
 * Request parameters for list operation in UserApi.
 */
export interface UserApiListRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: UserApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: UserApiCreateRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).create(requestParameters.userPostBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: UserApiEditRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).edit(requestParameters.id, requestParameters.userPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: UserApiFindRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).find(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: UserApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).list(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }
}



