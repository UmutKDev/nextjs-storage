/* tslint:disable */
/* eslint-disable */
/**
 * Base API Service
 * Base API Service Test Environment & Documentation
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AccountChangePasswordRequestModel {
    'CurrentPassword': string;
    'NewPassword': string;
    'NewPasswordConfirmation': string;
}
export interface AccountProfileResponseBaseModel {
    'Result': AccountProfileResponseModel;
    'Status': BaseStatusModel;
}
export interface AccountProfileResponseModel {
    'Id': string;
    'Email': string;
    'FullName': string;
    'PhoneNumber': string;
    'Image': string;
    'Role': AccountProfileResponseModelRoleEnum;
    'Status': AccountProfileResponseModelStatusEnum;
    'Subscription': UserSubscriptionResponseModel;
    'Date': UserDateModel;
}

export const AccountProfileResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type AccountProfileResponseModelRoleEnum = typeof AccountProfileResponseModelRoleEnum[keyof typeof AccountProfileResponseModelRoleEnum];
export const AccountProfileResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type AccountProfileResponseModelStatusEnum = typeof AccountProfileResponseModelStatusEnum[keyof typeof AccountProfileResponseModelStatusEnum];

export interface AccountPutBodyRequestModel {
    'FullName': string;
    'PhoneNumber': string;
}
export interface ApiKeyCreateRequestModel {
    'Name': string;
    'Scopes': Array<ApiKeyCreateRequestModelScopesEnum>;
    'Environment': ApiKeyCreateRequestModelEnvironmentEnum;
    'IpWhitelist'?: Array<string>;
    'RateLimitPerMinute'?: number;
    'ExpiresAt'?: string;
}

export const ApiKeyCreateRequestModelScopesEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Delete: 'DELETE',
    Admin: 'ADMIN'
} as const;

export type ApiKeyCreateRequestModelScopesEnum = typeof ApiKeyCreateRequestModelScopesEnum[keyof typeof ApiKeyCreateRequestModelScopesEnum];
export const ApiKeyCreateRequestModelEnvironmentEnum = {
    Test: 'TEST',
    Live: 'LIVE'
} as const;

export type ApiKeyCreateRequestModelEnvironmentEnum = typeof ApiKeyCreateRequestModelEnvironmentEnum[keyof typeof ApiKeyCreateRequestModelEnvironmentEnum];

export interface ApiKeyCreatedResponseBaseModel {
    'Result': ApiKeyCreatedResponseModel;
    'Status': BaseStatusModel;
}
export interface ApiKeyCreatedResponseModel {
    'Id': string;
    'Name': string;
    /**
     * Public key - can be shared
     */
    'PublicKey': string;
    /**
     * Secret key - shown only once!
     */
    'SecretKey': string;
    'Environment': string;
    'Scopes': Array<string>;
    'CreatedAt': string;
}
export interface ApiKeyRotateResponseBaseModel {
    'Result': ApiKeyRotateResponseModel;
    'Status': BaseStatusModel;
}
export interface ApiKeyRotateResponseModel {
    'Id': string;
    'PublicKey': string;
    /**
     * New secret key - shown only once!
     */
    'SecretKey': string;
}
export interface ApiKeyUpdateRequestModel {
    'Name'?: string;
    'Scopes'?: Array<ApiKeyUpdateRequestModelScopesEnum>;
    'IpWhitelist'?: Array<string>;
    'RateLimitPerMinute'?: number;
}

export const ApiKeyUpdateRequestModelScopesEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Delete: 'DELETE',
    Admin: 'ADMIN'
} as const;

export type ApiKeyUpdateRequestModelScopesEnum = typeof ApiKeyUpdateRequestModelScopesEnum[keyof typeof ApiKeyUpdateRequestModelScopesEnum];

export interface ApiKeyViewBaseModel {
    'Result': ApiKeyViewModel;
    'Status': BaseStatusModel;
}
export interface ApiKeyViewModel {
    'Id': string;
    'Name': string;
    'PublicKey': string;
    /**
     * First 8 characters of secret key
     */
    'SecretKeyPrefix': string;
    'Environment': string;
    'Scopes': Array<string>;
    'IpWhitelist': Array<string>;
    'RateLimitPerMinute': number;
    'LastUsedAt': string;
    'ExpiresAt': string;
    'IsRevoked': boolean;
    'CreatedAt': string;
}
export interface ArrayResponseModel {
    'Options': PaginationResponseModel;
    'Items': Array<Array<string>>;
}
export interface AuthenticationResponseBaseModel {
    'Result': AuthenticationResponseModel;
    'Status': BaseStatusModel;
}
export interface AuthenticationResponseModel {
    'SessionId': string;
    'ExpiresAt': string;
}
export interface BaseDateModel {
    'Created': string;
    'Updated': string;
}
export interface BaseResponseModel {
    'Result': object;
    'Status': BaseStatusModel;
}
export interface BaseStatusModel {
    'Messages': Array<string>;
    'Code': number;
    'Timestamp': string;
    'Path': string;
}
export interface BooleanResponseModel {
    'Result': boolean;
    'Status': BaseStatusModel;
}
export interface Check200Response {
    'status'?: string;
    'info'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'error'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'details'?: { [key: string]: Check200ResponseInfoValue; };
}
export interface Check200ResponseInfoValue {
    [key: string]: any;

    'status': string;
}
export interface Check503Response {
    'status'?: string;
    'info'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'error'?: { [key: string]: Check200ResponseInfoValue; } | null;
    'details'?: { [key: string]: Check200ResponseInfoValue; };
}
export interface CloudAbortMultipartUploadRequestModel {
    'Key': string;
    'UploadId': string;
}
export interface CloudBreadCrumbListBaseModel {
    'Result': CloudBreadCrumbListModelResult;
    'Status': BaseStatusModel;
}
export interface CloudBreadCrumbListModelResult {
    'Options': PaginationResponseModel;
    'Items': Array<CloudBreadCrumbModel>;
}
export interface CloudBreadCrumbModel {
    'Name': string;
    'Path': string;
    'Type': CloudBreadCrumbModelTypeEnum;
}

export const CloudBreadCrumbModelTypeEnum = {
    Root: 'ROOT',
    Subfolder: 'SUBFOLDER'
} as const;

export type CloudBreadCrumbModelTypeEnum = typeof CloudBreadCrumbModelTypeEnum[keyof typeof CloudBreadCrumbModelTypeEnum];

export interface CloudCompleteMultipartUploadRequestModel {
    'Key': string;
    'UploadId': string;
    'Parts': Array<CloudMultipartPartModel>;
}
export interface CloudCompleteMultipartUploadResponseBaseModel {
    'Result': CloudCompleteMultipartUploadResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudCompleteMultipartUploadResponseModel {
    'Location': string;
    'Key': string;
    'Bucket': string;
    'ETag': string;
    'Metadata'?: CloudMetadataDefaultModel;
}
export interface CloudCreateMultipartUploadRequestModel {
    'Key': string;
    'ContentType'?: string;
    'Metadata'?: object;
    'TotalSize': number;
}
export interface CloudCreateMultipartUploadResponseBaseModel {
    'Result': CloudCreateMultipartUploadResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudCreateMultipartUploadResponseModel {
    'UploadId': string;
    'Key': string;
}
export interface CloudDeleteModel {
    'Key': string;
    'IsDirectory'?: boolean;
}
export interface CloudDeleteRequestModel {
    'Items': Array<CloudDeleteModel>;
}
export interface CloudDirectoryListBaseModel {
    'Result': CloudDirectoryListModelResult;
    'Status': BaseStatusModel;
}
export interface CloudDirectoryListModelResult {
    'Options': PaginationResponseModel;
    'Items': Array<CloudDirectoryModel>;
}
export interface CloudDirectoryModel {
    'Name': string;
    'Prefix': string;
    'IsEncrypted': boolean;
    /**
     * True if encrypted folder is locked (no valid session)
     */
    'IsLocked': boolean;
    'Thumbnails'?: Array<CloudObjectModel>;
}
export interface CloudExtractZipCancelRequestModel {
    'JobId': string;
}
export interface CloudExtractZipCancelResponseBaseModel {
    'Result': CloudExtractZipCancelResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudExtractZipCancelResponseModel {
    'Cancelled': boolean;
}
export interface CloudExtractZipStartRequestModel {
    'Key': string;
}
export interface CloudExtractZipStartResponseBaseModel {
    'Result': CloudExtractZipStartResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudExtractZipStartResponseModel {
    'JobId': string;
}
export interface CloudExtractZipStatusResponseBaseModel {
    'Result': CloudExtractZipStatusResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudExtractZipStatusResponseModel {
    'JobId': string;
    'State': string;
    'Progress'?: object;
    'ExtractedPath'?: string;
    'FailedReason'?: string;
}
export interface CloudGetMultipartPartUrlRequestModel {
    'Key': string;
    'UploadId': string;
    'PartNumber': number;
}
export interface CloudGetMultipartPartUrlResponseBaseModel {
    'Result': CloudGetMultipartPartUrlResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudGetMultipartPartUrlResponseModel {
    'Url': string;
    'Expires': number;
}
export interface CloudListResponseBaseModel {
    'Result': CloudListResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudListResponseModel {
    'Breadcrumb': Array<CloudBreadCrumbModel>;
    'Directories': Array<CloudDirectoryModel>;
    'Contents': Array<CloudObjectModel>;
}
export interface CloudMetadataDefaultModel {
    'Originalfilename': string;
    'Width': string;
    'Height': string;
}
export interface CloudMoveRequestModel {
    'SourceKeys': Array<string>;
    'DestinationKey': string;
}
export interface CloudMultipartPartModel {
    'PartNumber': number;
    'ETag': string;
}
export interface CloudObjectBaseModel {
    'Result': CloudObjectModel;
    'Status': BaseStatusModel;
}
export interface CloudObjectListBaseModel {
    'Result': CloudObjectListModelResult;
    'Status': BaseStatusModel;
}
export interface CloudObjectListModelResult {
    'Options': PaginationResponseModel;
    'Items': Array<CloudObjectModel>;
}
export interface CloudObjectModel {
    'Name': string;
    'Extension': string;
    'MimeType': string;
    'Path': CloudPathModel;
    'Metadata'?: CloudMetadataDefaultModel;
    'LastModified': string;
    'ETag': string;
    'Size': number;
}
export interface CloudPathModel {
    'Host': string;
    'Key': string;
    'Url': string;
}
export interface CloudScanStatusResponseBaseModel {
    'Result': CloudScanStatusResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudScanStatusResponseModel {
    'Status': string;
    'Reason'?: string;
    'Signature'?: string;
    'ScannedAt'?: string;
}
export interface CloudUpdateRequestModel {
    'Key': string;
    'Name'?: string;
    'Metadata'?: object;
}
export interface CloudUploadPartRequestModel {
    'Key': string;
    'UploadId': string;
    'PartNumber': number;
    'File': File;
}
export interface CloudUploadPartResponseBaseModel {
    'Result': CloudUploadPartResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudUploadPartResponseModel {
    'ETag': string;
}
export interface CloudUserStorageUsageResponseBaseModel {
    'Result': CloudUserStorageUsageResponseModel;
    'Status': BaseStatusModel;
}
export interface CloudUserStorageUsageResponseModel {
    'UsedStorageInBytes': number;
    'MaxStorageInBytes': number;
    'IsLimitExceeded': boolean;
    'UsagePercentage': number;
    'MaxUploadSizeBytes': number;
}
export interface DefinitionGroupResponseListBaseModel {
    'Result': DefinitionGroupResponseListModelResult;
    'Status': BaseStatusModel;
}
export interface DefinitionGroupResponseListModelResult {
    'Options': PaginationResponseModel;
    'Items': Array<DefinitionGroupResponseModel>;
}
export interface DefinitionGroupResponseModel {
    'Id': string;
    'Code': string;
    'Description': string;
    'IsCommon': boolean;
    'Date': BaseDateModel;
}
export interface DirectoryConvertToEncryptedRequestModel {
    /**
     * Directory path to convert
     */
    'Path': string;
}
export interface DirectoryCreateRequestModel {
    /**
     * Directory path to create
     */
    'Path': string;
    /**
     * Create as encrypted directory
     */
    'IsEncrypted'?: boolean;
}
export interface DirectoryDecryptRequestModel {
    /**
     * Encrypted directory path to decrypt
     */
    'Path': string;
}
export interface DirectoryDeleteRequestModel {
    /**
     * Directory path to delete
     */
    'Path': string;
}
export interface DirectoryLockRequestModel {
    /**
     * Encrypted directory path to lock
     */
    'Path': string;
}
export interface DirectoryRenameRequestModel {
    /**
     * Current directory path
     */
    'Path': string;
    /**
     * New directory name (not full path)
     */
    'Name': string;
}
export interface DirectoryResponseBaseModel {
    'Result': DirectoryResponseModel;
    'Status': BaseStatusModel;
}
export interface DirectoryResponseModel {
    'Path': string;
    'IsEncrypted': boolean;
    'CreatedAt'?: string;
    'UpdatedAt'?: string;
}
export interface DirectoryUnlockRequestModel {
    /**
     * Encrypted directory path
     */
    'Path': string;
}
export interface DirectoryUnlockResponseBaseModel {
    'Result': DirectoryUnlockResponseModel;
    'Status': BaseStatusModel;
}
export interface DirectoryUnlockResponseModel {
    /**
     * Directory path that was requested for unlock
     */
    'Path': string;
    /**
     * The root encrypted folder path (parent folder that is actually encrypted)
     */
    'EncryptedFolderPath': string;
    /**
     * Session token for subsequent requests. Pass via X-Folder-Session header.
     */
    'SessionToken': string;
    /**
     * Session expiration timestamp (Unix epoch in seconds)
     */
    'ExpiresAt': number;
    /**
     * Session TTL in seconds
     */
    'TTL': number;
}
export interface InternalServerErrorResponseModel {
    'Result': any;
    'Status': InternalServerErrorResponseModelAllOfStatus;
}
export interface InternalServerErrorResponseModel1 {
    'Result': string;
    'Status': InternalServerErrorResponseModelAllOfStatus;
}
export interface InternalServerErrorResponseModelAllOfStatus {
    'Code'?: number;
    'Message'?: string;
}
export interface LoginCheckRequestModel {
    'Email': string;
}
export interface LoginCheckResponseBaseModel {
    'Result': LoginCheckResponseModel;
    'Status': BaseStatusModel;
}
export interface LoginCheckResponseModel {
    /**
     * Whether the user exists
     */
    'Exists': boolean;
    /**
     * Whether the user has passkey(s) registered
     */
    'HasPasskey': boolean;
    /**
     * Whether the user has 2FA enabled
     */
    'HasTwoFactor': boolean;
    /**
     * 2FA method if enabled (TOTP, etc.)
     */
    'TwoFactorMethod': string;
    /**
     * Available authentication methods
     */
    'AvailableMethods': Array<string>;
    /**
     * Passkey login options if passkey is available
     */
    'PasskeyOptions'?: object;
}
export interface LoginRequestModel {
    'Email': string;
    'Password': string;
}
export interface PaginationResponseModel {
    'Search': string;
    'Skip': number;
    'Take': number;
    'Count': number;
}
export interface PasskeyLoginBeginRequestModel {
    'Email': string;
}
export interface PasskeyLoginBeginResponseBaseModel {
    'Result': PasskeyLoginBeginResponseModel;
    'Status': BaseStatusModel;
}
export interface PasskeyLoginBeginResponseModel {
    'Challenge': string;
    'Options': object;
}
export interface PasskeyLoginFinishRequestModel {
    'Email': string;
    'Credential': object;
}
export interface PasskeyRegistrationBeginRequestModel {
    /**
     * Name for the passkey device
     */
    'DeviceName': string;
}
export interface PasskeyRegistrationBeginResponseBaseModel {
    'Result': PasskeyRegistrationBeginResponseModel;
    'Status': BaseStatusModel;
}
export interface PasskeyRegistrationBeginResponseModel {
    'Challenge': string;
    'Options': object;
}
export interface PasskeyRegistrationFinishRequestModel {
    'DeviceName': string;
    'Credential': object;
}
export interface PasskeyViewBaseModel {
    'Result': PasskeyViewModel;
    'Status': BaseStatusModel;
}
export interface PasskeyViewModel {
    'Id': string;
    'DeviceName': string;
    'DeviceType': string;
    'CreatedAt': string;
    'LastUsedAt': string;
}
export interface RegisterRequestModel {
    'Email': string;
    'Password': string;
    'PasswordConfirmation': string;
}
export interface ResetPasswordRequestModel {
    'Email': string;
}
export interface SessionViewBaseModel {
    'Result': SessionViewModel;
    'Status': BaseStatusModel;
}
export interface SessionViewModel {
    'Id': string;
    'DeviceInfo': object;
    'IpAddress': string;
    'CreatedAt': string;
    'LastActivityAt': string;
    'IsCurrent': boolean;
}
export interface StringResponseModel {
    'Result': string;
    'Status': BaseStatusModel;
}
export interface SubscribeAsAdminRequestModel {
    'SubscriptionId': string;
    'IsTrial'?: boolean;
    'ProviderSubscriptionId'?: string;
    'UserId': string;
}
export interface SubscribeRequestModel {
    'SubscriptionId': string;
    'IsTrial'?: boolean;
    'ProviderSubscriptionId'?: string;
}
export interface SubscriptionDateModel {
    'Created': string;
    'Updated': string;
}
export interface SubscriptionFindResponseBaseModel {
    'Result': SubscriptionFindResponseModel;
    'Status': BaseStatusModel;
}
export interface SubscriptionFindResponseModel {
    'Id': string;
    'Name': string;
    'Slug': string;
    'Description'?: string;
    'Currency': string;
    'BillingCycle': SubscriptionFindResponseModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'StorageLimitBytes': number;
    'MaxObjectCount'?: number;
    'Features'?: object;
    'Status': SubscriptionFindResponseModelStatusEnum;
    'Date': SubscriptionDateModel;
}

export const SubscriptionFindResponseModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionFindResponseModelBillingCycleEnum = typeof SubscriptionFindResponseModelBillingCycleEnum[keyof typeof SubscriptionFindResponseModelBillingCycleEnum];
export const SubscriptionFindResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionFindResponseModelStatusEnum = typeof SubscriptionFindResponseModelStatusEnum[keyof typeof SubscriptionFindResponseModelStatusEnum];

export interface SubscriptionListResponseListBaseModel {
    'Result': SubscriptionListResponseListModelResult;
    'Status': BaseStatusModel;
}
export interface SubscriptionListResponseListModelResult {
    'Options': PaginationResponseModel;
    'Items': Array<SubscriptionListResponseModel>;
}
export interface SubscriptionListResponseModel {
    'Id': string;
    'Name': string;
    'Slug': string;
    'Description'?: string;
    'Currency': string;
    'BillingCycle': SubscriptionListResponseModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'StorageLimitBytes': number;
    'MaxObjectCount'?: number;
    'Features'?: object;
    'Status': SubscriptionListResponseModelStatusEnum;
    'Date': SubscriptionDateModel;
}

export const SubscriptionListResponseModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionListResponseModelBillingCycleEnum = typeof SubscriptionListResponseModelBillingCycleEnum[keyof typeof SubscriptionListResponseModelBillingCycleEnum];
export const SubscriptionListResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionListResponseModelStatusEnum = typeof SubscriptionListResponseModelStatusEnum[keyof typeof SubscriptionListResponseModelStatusEnum];

export interface SubscriptionPostBodyRequestModel {
    'Name': string;
    'Slug': string;
    'Description'?: string;
    /**
     * Price in cents
     */
    'Price': number;
    'Currency': string;
    'BillingCycle': SubscriptionPostBodyRequestModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'StorageLimitBytes': number;
    'MaxObjectCount'?: number;
    'Features'?: object;
    'Status': SubscriptionPostBodyRequestModelStatusEnum;
}

export const SubscriptionPostBodyRequestModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionPostBodyRequestModelBillingCycleEnum = typeof SubscriptionPostBodyRequestModelBillingCycleEnum[keyof typeof SubscriptionPostBodyRequestModelBillingCycleEnum];
export const SubscriptionPostBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionPostBodyRequestModelStatusEnum = typeof SubscriptionPostBodyRequestModelStatusEnum[keyof typeof SubscriptionPostBodyRequestModelStatusEnum];

export interface SubscriptionPutBodyRequestModel {
    'Name': string;
    'Description'?: string;
    /**
     * Price in cents
     */
    'Price': number;
    'Currency': string;
    'BillingCycle': SubscriptionPutBodyRequestModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'StorageLimitBytes': number;
    'MaxObjectCount'?: number;
    'Features'?: object;
    'Status': SubscriptionPutBodyRequestModelStatusEnum;
}

export const SubscriptionPutBodyRequestModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionPutBodyRequestModelBillingCycleEnum = typeof SubscriptionPutBodyRequestModelBillingCycleEnum[keyof typeof SubscriptionPutBodyRequestModelBillingCycleEnum];
export const SubscriptionPutBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionPutBodyRequestModelStatusEnum = typeof SubscriptionPutBodyRequestModelStatusEnum[keyof typeof SubscriptionPutBodyRequestModelStatusEnum];

export interface SubscriptionResponseModel {
    'Id': string;
    'Name': string;
    'Slug': string;
    'Description'?: string;
    'Currency': string;
    'BillingCycle': SubscriptionResponseModelBillingCycleEnum;
    /**
     * Storage limit in bytes - 0 means unlimited
     */
    'StorageLimitBytes': number;
    'MaxObjectCount'?: number;
    'Features'?: object;
    'Status': SubscriptionResponseModelStatusEnum;
    'Date': SubscriptionDateModel;
}

export const SubscriptionResponseModelBillingCycleEnum = {
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY',
    Onetime: 'ONETIME',
    Trial: 'TRIAL'
} as const;

export type SubscriptionResponseModelBillingCycleEnum = typeof SubscriptionResponseModelBillingCycleEnum[keyof typeof SubscriptionResponseModelBillingCycleEnum];
export const SubscriptionResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    Trialing: 'TRIALING'
} as const;

export type SubscriptionResponseModelStatusEnum = typeof SubscriptionResponseModelStatusEnum[keyof typeof SubscriptionResponseModelStatusEnum];

export interface TwoFactorBackupCodesResponseBaseModel {
    'Result': TwoFactorBackupCodesResponseModel;
    'Status': BaseStatusModel;
}
export interface TwoFactorBackupCodesResponseModel {
    'BackupCodes': Array<string>;
}
export interface TwoFactorSetupResponseBaseModel {
    'Result': TwoFactorSetupResponseModel;
    'Status': BaseStatusModel;
}
export interface TwoFactorSetupResponseModel {
    'Secret': string;
    'Issuer': string;
    'AccountName': string;
    'OtpAuthUrl': string;
}
export interface TwoFactorStatusResponseBaseModel {
    'Result': TwoFactorStatusResponseModel;
    'Status': BaseStatusModel;
}
export interface TwoFactorStatusResponseModel {
    'IsEnabled': boolean;
    'Method': string;
    'HasPasskey': boolean;
    'BackupCodesRemaining': number;
}
export interface TwoFactorVerifyRequestModel {
    /**
     * TOTP code from authenticator app
     */
    'Code': string;
}
export interface UserDateModel {
    'Created': string;
    'Updated': string;
    'LastLogin': string;
}
export interface UserFindResponseBaseModel {
    'Result': UserFindResponseModel;
    'Status': BaseStatusModel;
}
export interface UserFindResponseModel {
    'Id': string;
    'Email': string;
    'FullName': string;
    'PhoneNumber': string;
    'Image': string;
    'Role': UserFindResponseModelRoleEnum;
    'Status': UserFindResponseModelStatusEnum;
    'Subscription': UserSubscriptionResponseModel;
    'Date': UserDateModel;
}

export const UserFindResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserFindResponseModelRoleEnum = typeof UserFindResponseModelRoleEnum[keyof typeof UserFindResponseModelRoleEnum];
export const UserFindResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserFindResponseModelStatusEnum = typeof UserFindResponseModelStatusEnum[keyof typeof UserFindResponseModelStatusEnum];

export interface UserListResponseListBaseModel {
    'Result': UserListResponseListModelResult;
    'Status': BaseStatusModel;
}
export interface UserListResponseListModelResult {
    'Options': PaginationResponseModel;
    'Items': Array<UserListResponseModel>;
}
export interface UserListResponseModel {
    'Id': string;
    'Email': string;
    'FullName': string;
    'PhoneNumber': string;
    'Image': string;
    'Role': UserListResponseModelRoleEnum;
    'Status': UserListResponseModelStatusEnum;
    'Subscription': UserSubscriptionResponseModel;
    'Date': UserDateModel;
}

export const UserListResponseModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserListResponseModelRoleEnum = typeof UserListResponseModelRoleEnum[keyof typeof UserListResponseModelRoleEnum];
export const UserListResponseModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserListResponseModelStatusEnum = typeof UserListResponseModelStatusEnum[keyof typeof UserListResponseModelStatusEnum];

export interface UserPostBodyRequestModel {
    'Email': string;
    'FullName': string;
    'PhoneNumber': string;
    'Image': string;
    'Role': UserPostBodyRequestModelRoleEnum;
    'Status': UserPostBodyRequestModelStatusEnum;
    'Subscription': UserSubscriptionResponseModel;
}

export const UserPostBodyRequestModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserPostBodyRequestModelRoleEnum = typeof UserPostBodyRequestModelRoleEnum[keyof typeof UserPostBodyRequestModelRoleEnum];
export const UserPostBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserPostBodyRequestModelStatusEnum = typeof UserPostBodyRequestModelStatusEnum[keyof typeof UserPostBodyRequestModelStatusEnum];

export interface UserPutBodyRequestModel {
    'FullName': string;
    'PhoneNumber': string;
    'Image': string;
    'Role': UserPutBodyRequestModelRoleEnum;
    'Status': UserPutBodyRequestModelStatusEnum;
    'Subscription': UserSubscriptionResponseModel;
}

export const UserPutBodyRequestModelRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserPutBodyRequestModelRoleEnum = typeof UserPutBodyRequestModelRoleEnum[keyof typeof UserPutBodyRequestModelRoleEnum];
export const UserPutBodyRequestModelStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Pending: 'PENDING',
    Suspended: 'SUSPENDED',
    Approval: 'APPROVAL'
} as const;

export type UserPutBodyRequestModelStatusEnum = typeof UserPutBodyRequestModelStatusEnum[keyof typeof UserPutBodyRequestModelStatusEnum];

export interface UserSubscriptionResponseModel {
    'Id': string;
    'StartAt': string;
    'EndAt'?: string;
    'IsTrial': boolean;
    /**
     * Price as cents
     */
    'Price': number;
    'Currency'?: string;
    'Subscription'?: SubscriptionResponseModel;
    'Date': BaseDateModel;
}

/**
 * AccountApi - axios parameter creator
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AccountChangePasswordRequestModel} accountChangePasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (accountChangePasswordRequestModel: AccountChangePasswordRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountChangePasswordRequestModel' is not null or undefined
            assertParamExists('changePassword', 'accountChangePasswordRequestModel', accountChangePasswordRequestModel)
            const localVarPath = `/Api/Account/ChangePassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountChangePasswordRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountPutBodyRequestModel} accountPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (accountPutBodyRequestModel: AccountPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'accountPutBodyRequestModel', accountPutBodyRequestModel)
            const localVarPath = `/Api/Account/Edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AccountChangePasswordRequestModel} accountChangePasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(accountChangePasswordRequestModel: AccountChangePasswordRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(accountChangePasswordRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.changePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AccountPutBodyRequestModel} accountPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(accountPutBodyRequestModel: AccountPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(accountPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountProfileResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.profile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @param {AccountApiChangePasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(requestParameters: AccountApiChangePasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.changePassword(requestParameters.accountChangePasswordRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: AccountApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.accountPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(options?: RawAxiosRequestConfig): AxiosPromise<AccountProfileResponseBaseModel> {
            return localVarFp.profile(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePassword operation in AccountApi.
 */
export interface AccountApiChangePasswordRequest {
    readonly accountChangePasswordRequestModel: AccountChangePasswordRequestModel
}

/**
 * Request parameters for edit operation in AccountApi.
 */
export interface AccountApiEditRequest {
    readonly accountPutBodyRequestModel: AccountPutBodyRequestModel
}

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @param {AccountApiChangePasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public changePassword(requestParameters: AccountApiChangePasswordRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).changePassword(requestParameters.accountChangePasswordRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: AccountApiEditRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).edit(requestParameters.accountPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public profile(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).profile(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountSecurityApi - axios parameter creator
 */
export const AccountSecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new API key
         * @param {ApiKeyCreateRequestModel} apiKeyCreateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey: async (apiKeyCreateRequestModel: ApiKeyCreateRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyCreateRequestModel' is not null or undefined
            assertParamExists('createApiKey', 'apiKeyCreateRequestModel', apiKeyCreateRequestModel)
            const localVarPath = `/Api/Account/Security/ApiKeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyCreateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a passkey
         * @param {string} passkeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasskey: async (passkeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyId' is not null or undefined
            assertParamExists('deletePasskey', 'passkeyId', passkeyId)
            const localVarPath = `/Api/Account/Security/Passkey/{passkeyId}`
                .replace(`{${"passkeyId"}}`, encodeURIComponent(String(passkeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/ApiKeys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get registered passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasskeys: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/Passkey`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/Sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/Sessions/LogoutAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout all other sessions except current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutOthers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/Sessions/LogoutOthers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begin passkey registration
         * @param {PasskeyRegistrationBeginRequestModel} passkeyRegistrationBeginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyRegisterBegin: async (passkeyRegistrationBeginRequestModel: PasskeyRegistrationBeginRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyRegistrationBeginRequestModel' is not null or undefined
            assertParamExists('passkeyRegisterBegin', 'passkeyRegistrationBeginRequestModel', passkeyRegistrationBeginRequestModel)
            const localVarPath = `/Api/Account/Security/Passkey/Register/Begin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyRegistrationBeginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete passkey registration
         * @param {PasskeyRegistrationFinishRequestModel} passkeyRegistrationFinishRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyRegisterFinish: async (passkeyRegistrationFinishRequestModel: PasskeyRegistrationFinishRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyRegistrationFinishRequestModel' is not null or undefined
            assertParamExists('passkeyRegisterFinish', 'passkeyRegistrationFinishRequestModel', passkeyRegistrationFinishRequestModel)
            const localVarPath = `/Api/Account/Security/Passkey/Register/Finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyRegistrationFinishRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regenerate backup codes
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateBackupCodes: async (twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorVerifyRequestModel' is not null or undefined
            assertParamExists('regenerateBackupCodes', 'twoFactorVerifyRequestModel', twoFactorVerifyRequestModel)
            const localVarPath = `/Api/Account/Security/TwoFactor/BackupCodes/Regenerate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorVerifyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke API key
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKey: async (apiKeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('revokeApiKey', 'apiKeyId', apiKeyId)
            const localVarPath = `/Api/Account/Security/ApiKeys/{apiKeyId}`
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('revokeSession', 'sessionId', sessionId)
            const localVarPath = `/Api/Account/Security/Sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Rotate API key secret
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiKey: async (apiKeyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('rotateApiKey', 'apiKeyId', apiKeyId)
            const localVarPath = `/Api/Account/Security/ApiKeys/{apiKeyId}/Rotate`
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disable TOTP 2FA
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorDisable: async (twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorVerifyRequestModel' is not null or undefined
            assertParamExists('twoFactorDisable', 'twoFactorVerifyRequestModel', twoFactorVerifyRequestModel)
            const localVarPath = `/Api/Account/Security/TwoFactor/TOTP/Disable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorVerifyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Setup TOTP 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorSetup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/TwoFactor/TOTP/Setup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get 2FA status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Account/Security/TwoFactor/Status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify and enable TOTP 2FA
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorVerify: async (twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorVerifyRequestModel' is not null or undefined
            assertParamExists('twoFactorVerify', 'twoFactorVerifyRequestModel', twoFactorVerifyRequestModel)
            const localVarPath = `/Api/Account/Security/TwoFactor/TOTP/Verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorVerifyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update API key
         * @param {string} apiKeyId 
         * @param {ApiKeyUpdateRequestModel} apiKeyUpdateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey: async (apiKeyId: string, apiKeyUpdateRequestModel: ApiKeyUpdateRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('updateApiKey', 'apiKeyId', apiKeyId)
            // verify required parameter 'apiKeyUpdateRequestModel' is not null or undefined
            assertParamExists('updateApiKey', 'apiKeyUpdateRequestModel', apiKeyUpdateRequestModel)
            const localVarPath = `/Api/Account/Security/ApiKeys/{apiKeyId}`
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiKeyUpdateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountSecurityApi - functional programming interface
 */
export const AccountSecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountSecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new API key
         * @param {ApiKeyCreateRequestModel} apiKeyCreateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey(apiKeyCreateRequestModel: ApiKeyCreateRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyCreatedResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey(apiKeyCreateRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.createApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a passkey
         * @param {string} passkeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePasskey(passkeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePasskey(passkeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.deletePasskey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getApiKeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyViewBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getApiKeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.getApiKeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get registered passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPasskeys(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyViewBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPasskeys(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.getPasskeys']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionViewBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.getSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.logoutAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout all other sessions except current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutOthers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutOthers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.logoutOthers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Begin passkey registration
         * @param {PasskeyRegistrationBeginRequestModel} passkeyRegistrationBeginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyRegisterBegin(passkeyRegistrationBeginRequestModel: PasskeyRegistrationBeginRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyRegistrationBeginResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyRegisterBegin(passkeyRegistrationBeginRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.passkeyRegisterBegin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Complete passkey registration
         * @param {PasskeyRegistrationFinishRequestModel} passkeyRegistrationFinishRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyRegisterFinish(passkeyRegistrationFinishRequestModel: PasskeyRegistrationFinishRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyViewBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyRegisterFinish(passkeyRegistrationFinishRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.passkeyRegisterFinish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Regenerate backup codes
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regenerateBackupCodes(twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorBackupCodesResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regenerateBackupCodes(twoFactorVerifyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.regenerateBackupCodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke API key
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeApiKey(apiKeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeApiKey(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.revokeApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke specific session
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.revokeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Rotate API key secret
         * @param {string} apiKeyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rotateApiKey(apiKeyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyRotateResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rotateApiKey(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.rotateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Disable TOTP 2FA
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twoFactorDisable(twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twoFactorDisable(twoFactorVerifyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.twoFactorDisable']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Setup TOTP 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twoFactorSetup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorSetupResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twoFactorSetup(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.twoFactorSetup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get 2FA status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twoFactorStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorStatusResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twoFactorStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.twoFactorStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify and enable TOTP 2FA
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async twoFactorVerify(twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TwoFactorBackupCodesResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.twoFactorVerify(twoFactorVerifyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.twoFactorVerify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update API key
         * @param {string} apiKeyId 
         * @param {ApiKeyUpdateRequestModel} apiKeyUpdateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateApiKey(apiKeyId: string, apiKeyUpdateRequestModel: ApiKeyUpdateRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyViewBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateApiKey(apiKeyId, apiKeyUpdateRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountSecurityApi.updateApiKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountSecurityApi - factory interface
 */
export const AccountSecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountSecurityApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new API key
         * @param {AccountSecurityApiCreateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey(requestParameters: AccountSecurityApiCreateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyCreatedResponseBaseModel> {
            return localVarFp.createApiKey(requestParameters.apiKeyCreateRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a passkey
         * @param {AccountSecurityApiDeletePasskeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePasskey(requestParameters: AccountSecurityApiDeletePasskeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.deletePasskey(requestParameters.passkeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApiKeys(options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyViewBaseModel> {
            return localVarFp.getApiKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get registered passkeys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPasskeys(options?: RawAxiosRequestConfig): AxiosPromise<PasskeyViewBaseModel> {
            return localVarFp.getPasskeys(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all active sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessions(options?: RawAxiosRequestConfig): AxiosPromise<SessionViewBaseModel> {
            return localVarFp.getSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout all sessions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutAll(options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.logoutAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout all other sessions except current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutOthers(options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.logoutOthers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Begin passkey registration
         * @param {AccountSecurityApiPasskeyRegisterBeginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyRegisterBegin(requestParameters: AccountSecurityApiPasskeyRegisterBeginRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasskeyRegistrationBeginResponseBaseModel> {
            return localVarFp.passkeyRegisterBegin(requestParameters.passkeyRegistrationBeginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete passkey registration
         * @param {AccountSecurityApiPasskeyRegisterFinishRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyRegisterFinish(requestParameters: AccountSecurityApiPasskeyRegisterFinishRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasskeyViewBaseModel> {
            return localVarFp.passkeyRegisterFinish(requestParameters.passkeyRegistrationFinishRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Regenerate backup codes
         * @param {AccountSecurityApiRegenerateBackupCodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateBackupCodes(requestParameters: AccountSecurityApiRegenerateBackupCodesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFactorBackupCodesResponseBaseModel> {
            return localVarFp.regenerateBackupCodes(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke API key
         * @param {AccountSecurityApiRevokeApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKey(requestParameters: AccountSecurityApiRevokeApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.revokeApiKey(requestParameters.apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke specific session
         * @param {AccountSecurityApiRevokeSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession(requestParameters: AccountSecurityApiRevokeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.revokeSession(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Rotate API key secret
         * @param {AccountSecurityApiRotateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rotateApiKey(requestParameters: AccountSecurityApiRotateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyRotateResponseBaseModel> {
            return localVarFp.rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Disable TOTP 2FA
         * @param {AccountSecurityApiTwoFactorDisableRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorDisable(requestParameters: AccountSecurityApiTwoFactorDisableRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.twoFactorDisable(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Setup TOTP 2FA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorSetup(options?: RawAxiosRequestConfig): AxiosPromise<TwoFactorSetupResponseBaseModel> {
            return localVarFp.twoFactorSetup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get 2FA status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorStatus(options?: RawAxiosRequestConfig): AxiosPromise<TwoFactorStatusResponseBaseModel> {
            return localVarFp.twoFactorStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify and enable TOTP 2FA
         * @param {AccountSecurityApiTwoFactorVerifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        twoFactorVerify(requestParameters: AccountSecurityApiTwoFactorVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<TwoFactorBackupCodesResponseBaseModel> {
            return localVarFp.twoFactorVerify(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update API key
         * @param {AccountSecurityApiUpdateApiKeyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApiKey(requestParameters: AccountSecurityApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyViewBaseModel> {
            return localVarFp.updateApiKey(requestParameters.apiKeyId, requestParameters.apiKeyUpdateRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApiKey operation in AccountSecurityApi.
 */
export interface AccountSecurityApiCreateApiKeyRequest {
    readonly apiKeyCreateRequestModel: ApiKeyCreateRequestModel
}

/**
 * Request parameters for deletePasskey operation in AccountSecurityApi.
 */
export interface AccountSecurityApiDeletePasskeyRequest {
    readonly passkeyId: string
}

/**
 * Request parameters for passkeyRegisterBegin operation in AccountSecurityApi.
 */
export interface AccountSecurityApiPasskeyRegisterBeginRequest {
    readonly passkeyRegistrationBeginRequestModel: PasskeyRegistrationBeginRequestModel
}

/**
 * Request parameters for passkeyRegisterFinish operation in AccountSecurityApi.
 */
export interface AccountSecurityApiPasskeyRegisterFinishRequest {
    readonly passkeyRegistrationFinishRequestModel: PasskeyRegistrationFinishRequestModel
}

/**
 * Request parameters for regenerateBackupCodes operation in AccountSecurityApi.
 */
export interface AccountSecurityApiRegenerateBackupCodesRequest {
    readonly twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel
}

/**
 * Request parameters for revokeApiKey operation in AccountSecurityApi.
 */
export interface AccountSecurityApiRevokeApiKeyRequest {
    readonly apiKeyId: string
}

/**
 * Request parameters for revokeSession operation in AccountSecurityApi.
 */
export interface AccountSecurityApiRevokeSessionRequest {
    readonly sessionId: string
}

/**
 * Request parameters for rotateApiKey operation in AccountSecurityApi.
 */
export interface AccountSecurityApiRotateApiKeyRequest {
    readonly apiKeyId: string
}

/**
 * Request parameters for twoFactorDisable operation in AccountSecurityApi.
 */
export interface AccountSecurityApiTwoFactorDisableRequest {
    readonly twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel
}

/**
 * Request parameters for twoFactorVerify operation in AccountSecurityApi.
 */
export interface AccountSecurityApiTwoFactorVerifyRequest {
    readonly twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel
}

/**
 * Request parameters for updateApiKey operation in AccountSecurityApi.
 */
export interface AccountSecurityApiUpdateApiKeyRequest {
    readonly apiKeyId: string

    readonly apiKeyUpdateRequestModel: ApiKeyUpdateRequestModel
}

/**
 * AccountSecurityApi - object-oriented interface
 */
export class AccountSecurityApi extends BaseAPI {
    /**
     * 
     * @summary Create new API key
     * @param {AccountSecurityApiCreateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createApiKey(requestParameters: AccountSecurityApiCreateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).createApiKey(requestParameters.apiKeyCreateRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a passkey
     * @param {AccountSecurityApiDeletePasskeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deletePasskey(requestParameters: AccountSecurityApiDeletePasskeyRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).deletePasskey(requestParameters.passkeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getApiKeys(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).getApiKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get registered passkeys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPasskeys(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).getPasskeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all active sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessions(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).getSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout all sessions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutAll(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).logoutAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout all other sessions except current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logoutOthers(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).logoutOthers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Begin passkey registration
     * @param {AccountSecurityApiPasskeyRegisterBeginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public passkeyRegisterBegin(requestParameters: AccountSecurityApiPasskeyRegisterBeginRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).passkeyRegisterBegin(requestParameters.passkeyRegistrationBeginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete passkey registration
     * @param {AccountSecurityApiPasskeyRegisterFinishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public passkeyRegisterFinish(requestParameters: AccountSecurityApiPasskeyRegisterFinishRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).passkeyRegisterFinish(requestParameters.passkeyRegistrationFinishRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Regenerate backup codes
     * @param {AccountSecurityApiRegenerateBackupCodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public regenerateBackupCodes(requestParameters: AccountSecurityApiRegenerateBackupCodesRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).regenerateBackupCodes(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke API key
     * @param {AccountSecurityApiRevokeApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeApiKey(requestParameters: AccountSecurityApiRevokeApiKeyRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).revokeApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke specific session
     * @param {AccountSecurityApiRevokeSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeSession(requestParameters: AccountSecurityApiRevokeSessionRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).revokeSession(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Rotate API key secret
     * @param {AccountSecurityApiRotateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rotateApiKey(requestParameters: AccountSecurityApiRotateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).rotateApiKey(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Disable TOTP 2FA
     * @param {AccountSecurityApiTwoFactorDisableRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public twoFactorDisable(requestParameters: AccountSecurityApiTwoFactorDisableRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).twoFactorDisable(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Setup TOTP 2FA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public twoFactorSetup(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).twoFactorSetup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get 2FA status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public twoFactorStatus(options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).twoFactorStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify and enable TOTP 2FA
     * @param {AccountSecurityApiTwoFactorVerifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public twoFactorVerify(requestParameters: AccountSecurityApiTwoFactorVerifyRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).twoFactorVerify(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update API key
     * @param {AccountSecurityApiUpdateApiKeyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateApiKey(requestParameters: AccountSecurityApiUpdateApiKeyRequest, options?: RawAxiosRequestConfig) {
        return AccountSecurityApiFp(this.configuration).updateApiKey(requestParameters.apiKeyId, requestParameters.apiKeyUpdateRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * After checking email with Login/Check, use this endpoint to authenticate with password. If 2FA is enabled, the response will have RequiresTwoFactor=true and you need to call Verify2FA.
         * @summary Step 2: Login with email and password
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequestModel: LoginRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequestModel' is not null or undefined
            assertParamExists('login', 'loginRequestModel', loginRequestModel)
            const localVarPath = `/Api/Authentication/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns available authentication methods (password, passkey), 2FA status, and passkey options if available. This should be the first step in the login flow.
         * @summary Step 1: Check email and get authentication requirements
         * @param {LoginCheckRequestModel} loginCheckRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheck: async (loginCheckRequestModel: LoginCheckRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCheckRequestModel' is not null or undefined
            assertParamExists('loginCheck', 'loginCheckRequestModel', loginCheckRequestModel)
            const localVarPath = `/Api/Authentication/Login/Check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCheckRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Authentication/Logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Alternative to password login. Use this if Login/Check returned HasPasskey=true. PasskeyOptions from Login/Check can also be used directly.
         * @summary Step 2 (Alternative): Begin passkey login
         * @param {PasskeyLoginBeginRequestModel} passkeyLoginBeginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginBegin: async (passkeyLoginBeginRequestModel: PasskeyLoginBeginRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyLoginBeginRequestModel' is not null or undefined
            assertParamExists('passkeyLoginBegin', 'passkeyLoginBeginRequestModel', passkeyLoginBeginRequestModel)
            const localVarPath = `/Api/Authentication/Passkey/Login/Begin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyLoginBeginRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Complete the passkey authentication. Note: Passkey login bypasses 2FA requirement.
         * @summary Step 2 (Alternative): Complete passkey login
         * @param {PasskeyLoginFinishRequestModel} passkeyLoginFinishRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginFinish: async (passkeyLoginFinishRequestModel: PasskeyLoginFinishRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passkeyLoginFinishRequestModel' is not null or undefined
            assertParamExists('passkeyLoginFinish', 'passkeyLoginFinishRequestModel', passkeyLoginFinishRequestModel)
            const localVarPath = `/Api/Authentication/Passkey/Login/Finish`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passkeyLoginFinishRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register new user
         * @param {RegisterRequestModel} registerRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequestModel: RegisterRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequestModel' is not null or undefined
            assertParamExists('register', 'registerRequestModel', registerRequestModel)
            const localVarPath = `/Api/Authentication/Register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password and send new password via email
         * @param {ResetPasswordRequestModel} resetPasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequestModel: ResetPasswordRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequestModel' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequestModel', resetPasswordRequestModel)
            const localVarPath = `/Api/Authentication/ResetPassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * If Login or Passkey/Login/Finish returns RequiresTwoFactor=true, use this endpoint to complete authentication with a TOTP code or backup code.
         * @summary Step 3: Verify 2FA code after login
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA: async (twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'twoFactorVerifyRequestModel' is not null or undefined
            assertParamExists('verify2FA', 'twoFactorVerifyRequestModel', twoFactorVerifyRequestModel)
            const localVarPath = `/Api/Authentication/Verify2FA`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(twoFactorVerifyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * After checking email with Login/Check, use this endpoint to authenticate with password. If 2FA is enabled, the response will have RequiresTwoFactor=true and you need to call Verify2FA.
         * @summary Step 2: Login with email and password
         * @param {LoginRequestModel} loginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequestModel: LoginRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns available authentication methods (password, passkey), 2FA status, and passkey options if available. This should be the first step in the login flow.
         * @summary Step 1: Check email and get authentication requirements
         * @param {LoginCheckRequestModel} loginCheckRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheck(loginCheckRequestModel: LoginCheckRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginCheckResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheck(loginCheckRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Alternative to password login. Use this if Login/Check returned HasPasskey=true. PasskeyOptions from Login/Check can also be used directly.
         * @summary Step 2 (Alternative): Begin passkey login
         * @param {PasskeyLoginBeginRequestModel} passkeyLoginBeginRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyLoginBegin(passkeyLoginBeginRequestModel: PasskeyLoginBeginRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasskeyLoginBeginResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyLoginBegin(passkeyLoginBeginRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.passkeyLoginBegin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Complete the passkey authentication. Note: Passkey login bypasses 2FA requirement.
         * @summary Step 2 (Alternative): Complete passkey login
         * @param {PasskeyLoginFinishRequestModel} passkeyLoginFinishRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async passkeyLoginFinish(passkeyLoginFinishRequestModel: PasskeyLoginFinishRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.passkeyLoginFinish(passkeyLoginFinishRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.passkeyLoginFinish']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Register new user
         * @param {RegisterRequestModel} registerRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequestModel: RegisterRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Reset password and send new password via email
         * @param {ResetPasswordRequestModel} resetPasswordRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequestModel: ResetPasswordRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * If Login or Passkey/Login/Finish returns RequiresTwoFactor=true, use this endpoint to complete authentication with a TOTP code or backup code.
         * @summary Step 3: Verify 2FA code after login
         * @param {TwoFactorVerifyRequestModel} twoFactorVerifyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify2FA(twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify2FA(twoFactorVerifyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.verify2FA']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * After checking email with Login/Check, use this endpoint to authenticate with password. If 2FA is enabled, the response will have RequiresTwoFactor=true and you need to call Verify2FA.
         * @summary Step 2: Login with email and password
         * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationResponseBaseModel> {
            return localVarFp.login(requestParameters.loginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns available authentication methods (password, passkey), 2FA status, and passkey options if available. This should be the first step in the login flow.
         * @summary Step 1: Check email and get authentication requirements
         * @param {AuthenticationApiLoginCheckRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheck(requestParameters: AuthenticationApiLoginCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginCheckResponseBaseModel> {
            return localVarFp.loginCheck(requestParameters.loginCheckRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * Alternative to password login. Use this if Login/Check returned HasPasskey=true. PasskeyOptions from Login/Check can also be used directly.
         * @summary Step 2 (Alternative): Begin passkey login
         * @param {AuthenticationApiPasskeyLoginBeginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginBegin(requestParameters: AuthenticationApiPasskeyLoginBeginRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasskeyLoginBeginResponseBaseModel> {
            return localVarFp.passkeyLoginBegin(requestParameters.passkeyLoginBeginRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Complete the passkey authentication. Note: Passkey login bypasses 2FA requirement.
         * @summary Step 2 (Alternative): Complete passkey login
         * @param {AuthenticationApiPasskeyLoginFinishRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        passkeyLoginFinish(requestParameters: AuthenticationApiPasskeyLoginFinishRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationResponseBaseModel> {
            return localVarFp.passkeyLoginFinish(requestParameters.passkeyLoginFinishRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register new user
         * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationResponseBaseModel> {
            return localVarFp.register(requestParameters.registerRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password and send new password via email
         * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.resetPassword(requestParameters.resetPasswordRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * If Login or Passkey/Login/Finish returns RequiresTwoFactor=true, use this endpoint to complete authentication with a TOTP code or backup code.
         * @summary Step 3: Verify 2FA code after login
         * @param {AuthenticationApiVerify2FARequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify2FA(requestParameters: AuthenticationApiVerify2FARequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationResponseBaseModel> {
            return localVarFp.verify2FA(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for login operation in AuthenticationApi.
 */
export interface AuthenticationApiLoginRequest {
    readonly loginRequestModel: LoginRequestModel
}

/**
 * Request parameters for loginCheck operation in AuthenticationApi.
 */
export interface AuthenticationApiLoginCheckRequest {
    readonly loginCheckRequestModel: LoginCheckRequestModel
}

/**
 * Request parameters for passkeyLoginBegin operation in AuthenticationApi.
 */
export interface AuthenticationApiPasskeyLoginBeginRequest {
    readonly passkeyLoginBeginRequestModel: PasskeyLoginBeginRequestModel
}

/**
 * Request parameters for passkeyLoginFinish operation in AuthenticationApi.
 */
export interface AuthenticationApiPasskeyLoginFinishRequest {
    readonly passkeyLoginFinishRequestModel: PasskeyLoginFinishRequestModel
}

/**
 * Request parameters for register operation in AuthenticationApi.
 */
export interface AuthenticationApiRegisterRequest {
    readonly registerRequestModel: RegisterRequestModel
}

/**
 * Request parameters for resetPassword operation in AuthenticationApi.
 */
export interface AuthenticationApiResetPasswordRequest {
    readonly resetPasswordRequestModel: ResetPasswordRequestModel
}

/**
 * Request parameters for verify2FA operation in AuthenticationApi.
 */
export interface AuthenticationApiVerify2FARequest {
    readonly twoFactorVerifyRequestModel: TwoFactorVerifyRequestModel
}

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * After checking email with Login/Check, use this endpoint to authenticate with password. If 2FA is enabled, the response will have RequiresTwoFactor=true and you need to call Verify2FA.
     * @summary Step 2: Login with email and password
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(requestParameters.loginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns available authentication methods (password, passkey), 2FA status, and passkey options if available. This should be the first step in the login flow.
     * @summary Step 1: Check email and get authentication requirements
     * @param {AuthenticationApiLoginCheckRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public loginCheck(requestParameters: AuthenticationApiLoginCheckRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginCheck(requestParameters.loginCheckRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Alternative to password login. Use this if Login/Check returned HasPasskey=true. PasskeyOptions from Login/Check can also be used directly.
     * @summary Step 2 (Alternative): Begin passkey login
     * @param {AuthenticationApiPasskeyLoginBeginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public passkeyLoginBegin(requestParameters: AuthenticationApiPasskeyLoginBeginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passkeyLoginBegin(requestParameters.passkeyLoginBeginRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Complete the passkey authentication. Note: Passkey login bypasses 2FA requirement.
     * @summary Step 2 (Alternative): Complete passkey login
     * @param {AuthenticationApiPasskeyLoginFinishRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public passkeyLoginFinish(requestParameters: AuthenticationApiPasskeyLoginFinishRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).passkeyLoginFinish(requestParameters.passkeyLoginFinishRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register new user
     * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(requestParameters.registerRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password and send new password via email
     * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPassword(requestParameters.resetPasswordRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * If Login or Passkey/Login/Finish returns RequiresTwoFactor=true, use this endpoint to complete authentication with a TOTP code or backup code.
     * @summary Step 3: Verify 2FA code after login
     * @param {AuthenticationApiVerify2FARequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verify2FA(requestParameters: AuthenticationApiVerify2FARequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).verify2FA(requestParameters.twoFactorVerifyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CloudApi - axios parameter creator
 */
export const CloudApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes one or more objects (or directories) belonging to the authenticated user.
         * @summary Delete objects
         * @param {string} idempotencyKey 
         * @param {CloudDeleteRequestModel} cloudDeleteRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (idempotencyKey: string, cloudDeleteRequestModel: CloudDeleteRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('_delete', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'cloudDeleteRequestModel' is not null or undefined
            assertParamExists('_delete', 'cloudDeleteRequestModel', cloudDeleteRequestModel)
            const localVarPath = `/Api/Cloud/Delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudDeleteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
         * @summary Convert a directory to encrypted
         * @param {string} xFolderPassphrase Passphrase for encryption (min 8 chars)
         * @param {DirectoryConvertToEncryptedRequestModel} directoryConvertToEncryptedRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryConvertToEncrypted: async (xFolderPassphrase: string, directoryConvertToEncryptedRequestModel: DirectoryConvertToEncryptedRequestModel, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xFolderPassphrase' is not null or undefined
            assertParamExists('directoryConvertToEncrypted', 'xFolderPassphrase', xFolderPassphrase)
            // verify required parameter 'directoryConvertToEncryptedRequestModel' is not null or undefined
            assertParamExists('directoryConvertToEncrypted', 'directoryConvertToEncryptedRequestModel', directoryConvertToEncryptedRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Encrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryConvertToEncryptedRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
         * @summary Create a directory
         * @param {DirectoryCreateRequestModel} directoryCreateRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory (min 8 chars)
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCreate: async (directoryCreateRequestModel: DirectoryCreateRequestModel, xFolderPassphrase?: string, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryCreateRequestModel' is not null or undefined
            assertParamExists('directoryCreate', 'directoryCreateRequestModel', directoryCreateRequestModel)
            const localVarPath = `/Api/Cloud/Directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryCreateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
         * @summary Remove encryption from a directory
         * @param {string} xFolderPassphrase Passphrase for decryption
         * @param {DirectoryDecryptRequestModel} directoryDecryptRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDecrypt: async (xFolderPassphrase: string, directoryDecryptRequestModel: DirectoryDecryptRequestModel, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xFolderPassphrase' is not null or undefined
            assertParamExists('directoryDecrypt', 'xFolderPassphrase', xFolderPassphrase)
            // verify required parameter 'directoryDecryptRequestModel' is not null or undefined
            assertParamExists('directoryDecrypt', 'directoryDecryptRequestModel', directoryDecryptRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Decrypt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryDecryptRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Delete a directory
         * @param {DirectoryDeleteRequestModel} directoryDeleteRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDelete: async (directoryDeleteRequestModel: DirectoryDeleteRequestModel, xFolderPassphrase?: string, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryDeleteRequestModel' is not null or undefined
            assertParamExists('directoryDelete', 'directoryDeleteRequestModel', directoryDeleteRequestModel)
            const localVarPath = `/Api/Cloud/Directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryDeleteRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the session token for an encrypted directory.
         * @summary Lock an encrypted directory
         * @param {DirectoryLockRequestModel} directoryLockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryLock: async (directoryLockRequestModel: DirectoryLockRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryLockRequestModel' is not null or undefined
            assertParamExists('directoryLock', 'directoryLockRequestModel', directoryLockRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Lock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryLockRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Rename a directory
         * @param {DirectoryRenameRequestModel} directoryRenameRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryRename: async (directoryRenameRequestModel: DirectoryRenameRequestModel, xFolderPassphrase?: string, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'directoryRenameRequestModel' is not null or undefined
            assertParamExists('directoryRename', 'directoryRenameRequestModel', directoryRenameRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Rename`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryRenameRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
         * @summary Unlock an encrypted directory
         * @param {string} xFolderPassphrase Passphrase for encrypted directory (min 8 chars)
         * @param {DirectoryUnlockRequestModel} directoryUnlockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryUnlock: async (xFolderPassphrase: string, directoryUnlockRequestModel: DirectoryUnlockRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xFolderPassphrase' is not null or undefined
            assertParamExists('directoryUnlock', 'xFolderPassphrase', xFolderPassphrase)
            // verify required parameter 'directoryUnlockRequestModel' is not null or undefined
            assertParamExists('directoryUnlock', 'directoryUnlockRequestModel', directoryUnlockRequestModel)
            const localVarPath = `/Api/Cloud/Directories/Unlock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderPassphrase != null) {
                localVarHeaderParameter['x-folder-passphrase'] = String(xFolderPassphrase);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(directoryUnlockRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
         * @summary Download a file for the authenticated user (streamed)
         * @param {string} key Path/key to the file (user-scoped)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('download', 'key', key)
            const localVarPath = `/Api/Cloud/Download`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a zip extraction job if it is pending or running.
         * @summary Cancel zip extraction
         * @param {CloudExtractZipCancelRequestModel} cloudExtractZipCancelRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractZipCancel: async (cloudExtractZipCancelRequestModel: CloudExtractZipCancelRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudExtractZipCancelRequestModel' is not null or undefined
            assertParamExists('extractZipCancel', 'cloudExtractZipCancelRequestModel', cloudExtractZipCancelRequestModel)
            const localVarPath = `/Api/Cloud/Upload/ExtractZip/Cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudExtractZipCancelRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts an async job to extract a previously uploaded .zip file.
         * @summary Start zip extraction
         * @param {CloudExtractZipStartRequestModel} cloudExtractZipStartRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractZipStart: async (cloudExtractZipStartRequestModel: CloudExtractZipStartRequestModel, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudExtractZipStartRequestModel' is not null or undefined
            assertParamExists('extractZipStart', 'cloudExtractZipStartRequestModel', cloudExtractZipStartRequestModel)
            const localVarPath = `/Api/Cloud/Upload/ExtractZip/Start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudExtractZipStartRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current status/progress of a zip extraction job.
         * @summary Get zip extraction status
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractZipStatus: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('extractZipStatus', 'jobId', jobId)
            const localVarPath = `/Api/Cloud/Upload/ExtractZip/Status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (jobId !== undefined) {
                localVarQueryParameter['JobId'] = jobId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Find a single object by key (user scoped) and return its metadata.
         * @summary Get object metadata
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('find', 'key', key)
            const localVarPath = `/Api/Cloud/Find`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a presigned URL for a specific object key to allow direct client access.
         * @summary Get a presigned URL for upload/download
         * @param {string} key 
         * @param {number} [expiresInSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrl: async (key: string, expiresInSeconds?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPresignedUrl', 'key', key)
            const localVarPath = `/Api/Cloud/PresignedUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }

            if (expiresInSeconds !== undefined) {
                localVarQueryParameter['ExpiresInSeconds'] = expiresInSeconds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List files and directories
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }

            if (isMetadataProcessing !== undefined) {
                localVarQueryParameter['IsMetadataProcessing'] = isMetadataProcessing;
            }


    
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns breadcrumb entries (path pieces) for the supplied path.
         * @summary Get breadcrumb for a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBreadcrumb: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List/Breadcrumb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List directories inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDirectories: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List/Directories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }


    
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List objects (files) inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects: async (search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/List/Objects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }

            if (path !== undefined) {
                localVarQueryParameter['Path'] = path;
            }

            if (delimiter !== undefined) {
                localVarQueryParameter['Delimiter'] = delimiter;
            }

            if (isMetadataProcessing !== undefined) {
                localVarQueryParameter['IsMetadataProcessing'] = isMetadataProcessing;
            }


    
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move an object from SourceKey to DestinationKey within the user scope.
         * @summary Move/rename an object
         * @param {string} idempotencyKey 
         * @param {CloudMoveRequestModel} cloudMoveRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move: async (idempotencyKey: string, cloudMoveRequestModel: CloudMoveRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('move', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'cloudMoveRequestModel' is not null or undefined
            assertParamExists('move', 'cloudMoveRequestModel', cloudMoveRequestModel)
            const localVarPath = `/Api/Cloud/Move`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudMoveRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest antivirus scan status for the given object key.
         * @summary Get antivirus scan status for a file
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanStatus: async (key: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('scanStatus', 'key', key)
            const localVarPath = `/Api/Cloud/Scan/Status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (key !== undefined) {
                localVarQueryParameter['Key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing object by changing metadata or renaming the file (name only).
         * @summary Update object metadata or rename
         * @param {CloudUpdateRequestModel} cloudUpdateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (cloudUpdateRequestModel: CloudUpdateRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudUpdateRequestModel' is not null or undefined
            assertParamExists('update', 'cloudUpdateRequestModel', cloudUpdateRequestModel)
            const localVarPath = `/Api/Cloud/Update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudUpdateRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Abort an ongoing multipart upload and clean up temporary state.
         * @summary Abort a multipart upload
         * @param {CloudAbortMultipartUploadRequestModel} cloudAbortMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAbortMultipartUpload: async (cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudAbortMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadAbortMultipartUpload', 'cloudAbortMultipartUploadRequestModel', cloudAbortMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/AbortMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudAbortMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a multipart upload by providing the list of parts and finalizes the object.
         * @summary Complete multipart upload
         * @param {string} idempotencyKey 
         * @param {CloudCompleteMultipartUploadRequestModel} cloudCompleteMultipartUploadRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompleteMultipartUpload: async (idempotencyKey: string, cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idempotencyKey' is not null or undefined
            assertParamExists('uploadCompleteMultipartUpload', 'idempotencyKey', idempotencyKey)
            // verify required parameter 'cloudCompleteMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadCompleteMultipartUpload', 'cloudCompleteMultipartUploadRequestModel', cloudCompleteMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/CompleteMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            if (idempotencyKey != null) {
                localVarHeaderParameter['idempotency-key'] = String(idempotencyKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudCompleteMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates an UploadId and starts a multipart upload flow.
         * @summary Create a multipart upload session
         * @param {CloudCreateMultipartUploadRequestModel} cloudCreateMultipartUploadRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCreateMultipartUpload: async (cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudCreateMultipartUploadRequestModel' is not null or undefined
            assertParamExists('uploadCreateMultipartUpload', 'cloudCreateMultipartUploadRequestModel', cloudCreateMultipartUploadRequestModel)
            const localVarPath = `/Api/Cloud/Upload/CreateMultipartUpload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudCreateMultipartUploadRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
         * @summary Get a multipart upload part URL
         * @param {CloudGetMultipartPartUrlRequestModel} cloudGetMultipartPartUrlRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGetMultipartPartUrl: async (cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cloudGetMultipartPartUrlRequestModel' is not null or undefined
            assertParamExists('uploadGetMultipartPartUrl', 'cloudGetMultipartPartUrlRequestModel', cloudGetMultipartPartUrlRequestModel)
            const localVarPath = `/Api/Cloud/Upload/GetMultipartPartUrl`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cloudGetMultipartPartUrlRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
         * @summary Upload a multipart part
         * @param {string} contentMd5 
         * @param {string} key 
         * @param {string} uploadId 
         * @param {number} partNumber 
         * @param {File} file 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart: async (contentMd5: string, key: string, uploadId: string, partNumber: number, file: File, xFolderSession?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentMd5' is not null or undefined
            assertParamExists('uploadPart', 'contentMd5', contentMd5)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('uploadPart', 'key', key)
            // verify required parameter 'uploadId' is not null or undefined
            assertParamExists('uploadPart', 'uploadId', uploadId)
            // verify required parameter 'partNumber' is not null or undefined
            assertParamExists('uploadPart', 'partNumber', partNumber)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadPart', 'file', file)
            const localVarPath = `/Api/Cloud/Upload/UploadPart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication cookie required


            if (key !== undefined) { 
                localVarFormParams.append('Key', key as any);
            }
    
            if (uploadId !== undefined) { 
                localVarFormParams.append('UploadId', uploadId as any);
            }
    
            if (partNumber !== undefined) { 
                localVarFormParams.append('PartNumber', partNumber as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('File', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (contentMd5 != null) {
                localVarHeaderParameter['content-md5'] = String(contentMd5);
            }
            if (xFolderSession != null) {
                localVarHeaderParameter['x-folder-session'] = String(xFolderSession);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the authenticated user storage usage and limits.
         * @summary Get user\'s storage usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStorageUsage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Cloud/User/StorageUsage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CloudApi - functional programming interface
 */
export const CloudApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CloudApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes one or more objects (or directories) belonging to the authenticated user.
         * @summary Delete objects
         * @param {string} idempotencyKey 
         * @param {CloudDeleteRequestModel} cloudDeleteRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(idempotencyKey: string, cloudDeleteRequestModel: CloudDeleteRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(idempotencyKey, cloudDeleteRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
         * @summary Convert a directory to encrypted
         * @param {string} xFolderPassphrase Passphrase for encryption (min 8 chars)
         * @param {DirectoryConvertToEncryptedRequestModel} directoryConvertToEncryptedRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryConvertToEncrypted(xFolderPassphrase: string, directoryConvertToEncryptedRequestModel: DirectoryConvertToEncryptedRequestModel, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryConvertToEncrypted(xFolderPassphrase, directoryConvertToEncryptedRequestModel, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryConvertToEncrypted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
         * @summary Create a directory
         * @param {DirectoryCreateRequestModel} directoryCreateRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory (min 8 chars)
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryCreate(directoryCreateRequestModel: DirectoryCreateRequestModel, xFolderPassphrase?: string, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryCreate(directoryCreateRequestModel, xFolderPassphrase, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
         * @summary Remove encryption from a directory
         * @param {string} xFolderPassphrase Passphrase for decryption
         * @param {DirectoryDecryptRequestModel} directoryDecryptRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryDecrypt(xFolderPassphrase: string, directoryDecryptRequestModel: DirectoryDecryptRequestModel, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryDecrypt(xFolderPassphrase, directoryDecryptRequestModel, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryDecrypt']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Delete a directory
         * @param {DirectoryDeleteRequestModel} directoryDeleteRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryDelete(directoryDeleteRequestModel: DirectoryDeleteRequestModel, xFolderPassphrase?: string, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryDelete(directoryDeleteRequestModel, xFolderPassphrase, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates the session token for an encrypted directory.
         * @summary Lock an encrypted directory
         * @param {DirectoryLockRequestModel} directoryLockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryLock(directoryLockRequestModel: DirectoryLockRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryLock(directoryLockRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryLock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Rename a directory
         * @param {DirectoryRenameRequestModel} directoryRenameRequestModel 
         * @param {string} [xFolderPassphrase] Passphrase for encrypted directory
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryRename(directoryRenameRequestModel: DirectoryRenameRequestModel, xFolderPassphrase?: string, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryRename(directoryRenameRequestModel, xFolderPassphrase, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryRename']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
         * @summary Unlock an encrypted directory
         * @param {string} xFolderPassphrase Passphrase for encrypted directory (min 8 chars)
         * @param {DirectoryUnlockRequestModel} directoryUnlockRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async directoryUnlock(xFolderPassphrase: string, directoryUnlockRequestModel: DirectoryUnlockRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DirectoryUnlockResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.directoryUnlock(xFolderPassphrase, directoryUnlockRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.directoryUnlock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
         * @summary Download a file for the authenticated user (streamed)
         * @param {string} key Path/key to the file (user-scoped)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.download']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancels a zip extraction job if it is pending or running.
         * @summary Cancel zip extraction
         * @param {CloudExtractZipCancelRequestModel} cloudExtractZipCancelRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractZipCancel(cloudExtractZipCancelRequestModel: CloudExtractZipCancelRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudExtractZipCancelResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractZipCancel(cloudExtractZipCancelRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.extractZipCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts an async job to extract a previously uploaded .zip file.
         * @summary Start zip extraction
         * @param {CloudExtractZipStartRequestModel} cloudExtractZipStartRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractZipStart(cloudExtractZipStartRequestModel: CloudExtractZipStartRequestModel, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudExtractZipStartResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractZipStart(cloudExtractZipStartRequestModel, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.extractZipStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current status/progress of a zip extraction job.
         * @summary Get zip extraction status
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extractZipStatus(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudExtractZipStatusResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extractZipStatus(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.extractZipStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Find a single object by key (user scoped) and return its metadata.
         * @summary Get object metadata
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a presigned URL for a specific object key to allow direct client access.
         * @summary Get a presigned URL for upload/download
         * @param {string} key 
         * @param {number} [expiresInSeconds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrl(key: string, expiresInSeconds?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrl(key, expiresInSeconds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.getPresignedUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List files and directories
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudListResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(search, skip, take, path, delimiter, isMetadataProcessing, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns breadcrumb entries (path pieces) for the supplied path.
         * @summary Get breadcrumb for a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBreadcrumb(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudBreadCrumbListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBreadcrumb(search, skip, take, path, delimiter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listBreadcrumb']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List directories inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDirectories(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudDirectoryListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDirectories(search, skip, take, path, delimiter, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listDirectories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List objects (files) inside a path
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {string} [path] 
         * @param {boolean} [delimiter] 
         * @param {boolean} [isMetadataProcessing] 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listObjects(search?: string, skip?: number, take?: number, path?: string, delimiter?: boolean, isMetadataProcessing?: boolean, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudObjectListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listObjects(search, skip, take, path, delimiter, isMetadataProcessing, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.listObjects']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Move an object from SourceKey to DestinationKey within the user scope.
         * @summary Move/rename an object
         * @param {string} idempotencyKey 
         * @param {CloudMoveRequestModel} cloudMoveRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async move(idempotencyKey: string, cloudMoveRequestModel: CloudMoveRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.move(idempotencyKey, cloudMoveRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.move']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the latest antivirus scan status for the given object key.
         * @summary Get antivirus scan status for a file
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scanStatus(key: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudScanStatusResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scanStatus(key, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.scanStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing object by changing metadata or renaming the file (name only).
         * @summary Update object metadata or rename
         * @param {CloudUpdateRequestModel} cloudUpdateRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(cloudUpdateRequestModel: CloudUpdateRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudObjectBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(cloudUpdateRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Abort an ongoing multipart upload and clean up temporary state.
         * @summary Abort a multipart upload
         * @param {CloudAbortMultipartUploadRequestModel} cloudAbortMultipartUploadRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadAbortMultipartUpload(cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadAbortMultipartUpload(cloudAbortMultipartUploadRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadAbortMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Completes a multipart upload by providing the list of parts and finalizes the object.
         * @summary Complete multipart upload
         * @param {string} idempotencyKey 
         * @param {CloudCompleteMultipartUploadRequestModel} cloudCompleteMultipartUploadRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCompleteMultipartUpload(idempotencyKey: string, cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudCompleteMultipartUploadResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCompleteMultipartUpload(idempotencyKey, cloudCompleteMultipartUploadRequestModel, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadCompleteMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates an UploadId and starts a multipart upload flow.
         * @summary Create a multipart upload session
         * @param {CloudCreateMultipartUploadRequestModel} cloudCreateMultipartUploadRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadCreateMultipartUpload(cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudCreateMultipartUploadResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadCreateMultipartUpload(cloudCreateMultipartUploadRequestModel, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadCreateMultipartUpload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
         * @summary Get a multipart upload part URL
         * @param {CloudGetMultipartPartUrlRequestModel} cloudGetMultipartPartUrlRequestModel 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadGetMultipartPartUrl(cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudGetMultipartPartUrlResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadGetMultipartPartUrl(cloudGetMultipartPartUrlRequestModel, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadGetMultipartPartUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
         * @summary Upload a multipart part
         * @param {string} contentMd5 
         * @param {string} key 
         * @param {string} uploadId 
         * @param {number} partNumber 
         * @param {File} file 
         * @param {string} [xFolderSession] Session token for encrypted folder access
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPart(contentMd5: string, key: string, uploadId: string, partNumber: number, file: File, xFolderSession?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUploadPartResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPart(contentMd5, key, uploadId, partNumber, file, xFolderSession, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.uploadPart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the authenticated user storage usage and limits.
         * @summary Get user\'s storage usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userStorageUsage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CloudUserStorageUsageResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userStorageUsage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CloudApi.userStorageUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CloudApi - factory interface
 */
export const CloudApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CloudApiFp(configuration)
    return {
        /**
         * Deletes one or more objects (or directories) belonging to the authenticated user.
         * @summary Delete objects
         * @param {CloudApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: CloudApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp._delete(requestParameters.idempotencyKey, requestParameters.cloudDeleteRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
         * @summary Convert a directory to encrypted
         * @param {CloudApiDirectoryConvertToEncryptedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryConvertToEncrypted(requestParameters: CloudApiDirectoryConvertToEncryptedRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryConvertToEncrypted(requestParameters.xFolderPassphrase, requestParameters.directoryConvertToEncryptedRequestModel, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
         * @summary Create a directory
         * @param {CloudApiDirectoryCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryCreate(requestParameters: CloudApiDirectoryCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryCreate(requestParameters.directoryCreateRequestModel, requestParameters.xFolderPassphrase, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
         * @summary Remove encryption from a directory
         * @param {CloudApiDirectoryDecryptRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDecrypt(requestParameters: CloudApiDirectoryDecryptRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryDecrypt(requestParameters.xFolderPassphrase, requestParameters.directoryDecryptRequestModel, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Delete a directory
         * @param {CloudApiDirectoryDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryDelete(requestParameters: CloudApiDirectoryDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.directoryDelete(requestParameters.directoryDeleteRequestModel, requestParameters.xFolderPassphrase, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the session token for an encrypted directory.
         * @summary Lock an encrypted directory
         * @param {CloudApiDirectoryLockRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryLock(requestParameters: CloudApiDirectoryLockRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.directoryLock(requestParameters.directoryLockRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
         * @summary Rename a directory
         * @param {CloudApiDirectoryRenameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryRename(requestParameters: CloudApiDirectoryRenameRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryResponseBaseModel> {
            return localVarFp.directoryRename(requestParameters.directoryRenameRequestModel, requestParameters.xFolderPassphrase, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
         * @summary Unlock an encrypted directory
         * @param {CloudApiDirectoryUnlockRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        directoryUnlock(requestParameters: CloudApiDirectoryUnlockRequest, options?: RawAxiosRequestConfig): AxiosPromise<DirectoryUnlockResponseBaseModel> {
            return localVarFp.directoryUnlock(requestParameters.xFolderPassphrase, requestParameters.directoryUnlockRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
         * @summary Download a file for the authenticated user (streamed)
         * @param {CloudApiDownloadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(requestParameters: CloudApiDownloadRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.download(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a zip extraction job if it is pending or running.
         * @summary Cancel zip extraction
         * @param {CloudApiExtractZipCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractZipCancel(requestParameters: CloudApiExtractZipCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudExtractZipCancelResponseBaseModel> {
            return localVarFp.extractZipCancel(requestParameters.cloudExtractZipCancelRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts an async job to extract a previously uploaded .zip file.
         * @summary Start zip extraction
         * @param {CloudApiExtractZipStartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractZipStart(requestParameters: CloudApiExtractZipStartRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudExtractZipStartResponseBaseModel> {
            return localVarFp.extractZipStart(requestParameters.cloudExtractZipStartRequestModel, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current status/progress of a zip extraction job.
         * @summary Get zip extraction status
         * @param {CloudApiExtractZipStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extractZipStatus(requestParameters: CloudApiExtractZipStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudExtractZipStatusResponseBaseModel> {
            return localVarFp.extractZipStatus(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Find a single object by key (user scoped) and return its metadata.
         * @summary Get object metadata
         * @param {CloudApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: CloudApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.find(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a presigned URL for a specific object key to allow direct client access.
         * @summary Get a presigned URL for upload/download
         * @param {CloudApiGetPresignedUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrl(requestParameters: CloudApiGetPresignedUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<StringResponseModel> {
            return localVarFp.getPresignedUrl(requestParameters.key, requestParameters.expiresInSeconds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List files and directories
         * @param {CloudApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: CloudApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudListResponseBaseModel> {
            return localVarFp.list(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns breadcrumb entries (path pieces) for the supplied path.
         * @summary Get breadcrumb for a path
         * @param {CloudApiListBreadcrumbRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBreadcrumb(requestParameters: CloudApiListBreadcrumbRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudBreadCrumbListBaseModel> {
            return localVarFp.listBreadcrumb(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List directories inside a path
         * @param {CloudApiListDirectoriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDirectories(requestParameters: CloudApiListDirectoriesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudDirectoryListBaseModel> {
            return localVarFp.listDirectories(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
         * @summary List objects (files) inside a path
         * @param {CloudApiListObjectsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listObjects(requestParameters: CloudApiListObjectsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CloudObjectListBaseModel> {
            return localVarFp.listObjects(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Move an object from SourceKey to DestinationKey within the user scope.
         * @summary Move/rename an object
         * @param {CloudApiMoveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(requestParameters: CloudApiMoveRequest, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.move(requestParameters.idempotencyKey, requestParameters.cloudMoveRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest antivirus scan status for the given object key.
         * @summary Get antivirus scan status for a file
         * @param {CloudApiScanStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanStatus(requestParameters: CloudApiScanStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudScanStatusResponseBaseModel> {
            return localVarFp.scanStatus(requestParameters.key, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing object by changing metadata or renaming the file (name only).
         * @summary Update object metadata or rename
         * @param {CloudApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: CloudApiUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudObjectBaseModel> {
            return localVarFp.update(requestParameters.cloudUpdateRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Abort an ongoing multipart upload and clean up temporary state.
         * @summary Abort a multipart upload
         * @param {CloudApiUploadAbortMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadAbortMultipartUpload(requestParameters: CloudApiUploadAbortMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadAbortMultipartUpload(requestParameters.cloudAbortMultipartUploadRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * Completes a multipart upload by providing the list of parts and finalizes the object.
         * @summary Complete multipart upload
         * @param {CloudApiUploadCompleteMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCompleteMultipartUpload(requestParameters: CloudApiUploadCompleteMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudCompleteMultipartUploadResponseBaseModel> {
            return localVarFp.uploadCompleteMultipartUpload(requestParameters.idempotencyKey, requestParameters.cloudCompleteMultipartUploadRequestModel, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates an UploadId and starts a multipart upload flow.
         * @summary Create a multipart upload session
         * @param {CloudApiUploadCreateMultipartUploadRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCreateMultipartUpload(requestParameters: CloudApiUploadCreateMultipartUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudCreateMultipartUploadResponseBaseModel> {
            return localVarFp.uploadCreateMultipartUpload(requestParameters.cloudCreateMultipartUploadRequestModel, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
         * @summary Get a multipart upload part URL
         * @param {CloudApiUploadGetMultipartPartUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadGetMultipartPartUrl(requestParameters: CloudApiUploadGetMultipartPartUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudGetMultipartPartUrlResponseBaseModel> {
            return localVarFp.uploadGetMultipartPartUrl(requestParameters.cloudGetMultipartPartUrlRequestModel, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
         * @summary Upload a multipart part
         * @param {CloudApiUploadPartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPart(requestParameters: CloudApiUploadPartRequest, options?: RawAxiosRequestConfig): AxiosPromise<CloudUploadPartResponseBaseModel> {
            return localVarFp.uploadPart(requestParameters.contentMd5, requestParameters.key, requestParameters.uploadId, requestParameters.partNumber, requestParameters.file, requestParameters.xFolderSession, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the authenticated user storage usage and limits.
         * @summary Get user\'s storage usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStorageUsage(options?: RawAxiosRequestConfig): AxiosPromise<CloudUserStorageUsageResponseBaseModel> {
            return localVarFp.userStorageUsage(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in CloudApi.
 */
export interface CloudApiDeleteRequest {
    readonly idempotencyKey: string

    readonly cloudDeleteRequestModel: CloudDeleteRequestModel
}

/**
 * Request parameters for directoryConvertToEncrypted operation in CloudApi.
 */
export interface CloudApiDirectoryConvertToEncryptedRequest {
    /**
     * Passphrase for encryption (min 8 chars)
     */
    readonly xFolderPassphrase: string

    readonly directoryConvertToEncryptedRequestModel: DirectoryConvertToEncryptedRequestModel

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for directoryCreate operation in CloudApi.
 */
export interface CloudApiDirectoryCreateRequest {
    readonly directoryCreateRequestModel: DirectoryCreateRequestModel

    /**
     * Passphrase for encrypted directory (min 8 chars)
     */
    readonly xFolderPassphrase?: string

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for directoryDecrypt operation in CloudApi.
 */
export interface CloudApiDirectoryDecryptRequest {
    /**
     * Passphrase for decryption
     */
    readonly xFolderPassphrase: string

    readonly directoryDecryptRequestModel: DirectoryDecryptRequestModel

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for directoryDelete operation in CloudApi.
 */
export interface CloudApiDirectoryDeleteRequest {
    readonly directoryDeleteRequestModel: DirectoryDeleteRequestModel

    /**
     * Passphrase for encrypted directory
     */
    readonly xFolderPassphrase?: string

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for directoryLock operation in CloudApi.
 */
export interface CloudApiDirectoryLockRequest {
    readonly directoryLockRequestModel: DirectoryLockRequestModel
}

/**
 * Request parameters for directoryRename operation in CloudApi.
 */
export interface CloudApiDirectoryRenameRequest {
    readonly directoryRenameRequestModel: DirectoryRenameRequestModel

    /**
     * Passphrase for encrypted directory
     */
    readonly xFolderPassphrase?: string

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for directoryUnlock operation in CloudApi.
 */
export interface CloudApiDirectoryUnlockRequest {
    /**
     * Passphrase for encrypted directory (min 8 chars)
     */
    readonly xFolderPassphrase: string

    readonly directoryUnlockRequestModel: DirectoryUnlockRequestModel
}

/**
 * Request parameters for download operation in CloudApi.
 */
export interface CloudApiDownloadRequest {
    /**
     * Path/key to the file (user-scoped)
     */
    readonly key: string
}

/**
 * Request parameters for extractZipCancel operation in CloudApi.
 */
export interface CloudApiExtractZipCancelRequest {
    readonly cloudExtractZipCancelRequestModel: CloudExtractZipCancelRequestModel
}

/**
 * Request parameters for extractZipStart operation in CloudApi.
 */
export interface CloudApiExtractZipStartRequest {
    readonly cloudExtractZipStartRequestModel: CloudExtractZipStartRequestModel

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for extractZipStatus operation in CloudApi.
 */
export interface CloudApiExtractZipStatusRequest {
    readonly jobId: string
}

/**
 * Request parameters for find operation in CloudApi.
 */
export interface CloudApiFindRequest {
    readonly key: string
}

/**
 * Request parameters for getPresignedUrl operation in CloudApi.
 */
export interface CloudApiGetPresignedUrlRequest {
    readonly key: string

    readonly expiresInSeconds?: number
}

/**
 * Request parameters for list operation in CloudApi.
 */
export interface CloudApiListRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean

    readonly isMetadataProcessing?: boolean

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for listBreadcrumb operation in CloudApi.
 */
export interface CloudApiListBreadcrumbRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean
}

/**
 * Request parameters for listDirectories operation in CloudApi.
 */
export interface CloudApiListDirectoriesRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for listObjects operation in CloudApi.
 */
export interface CloudApiListObjectsRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number

    readonly path?: string

    readonly delimiter?: boolean

    readonly isMetadataProcessing?: boolean

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for move operation in CloudApi.
 */
export interface CloudApiMoveRequest {
    readonly idempotencyKey: string

    readonly cloudMoveRequestModel: CloudMoveRequestModel
}

/**
 * Request parameters for scanStatus operation in CloudApi.
 */
export interface CloudApiScanStatusRequest {
    readonly key: string
}

/**
 * Request parameters for update operation in CloudApi.
 */
export interface CloudApiUpdateRequest {
    readonly cloudUpdateRequestModel: CloudUpdateRequestModel
}

/**
 * Request parameters for uploadAbortMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadAbortMultipartUploadRequest {
    readonly cloudAbortMultipartUploadRequestModel: CloudAbortMultipartUploadRequestModel
}

/**
 * Request parameters for uploadCompleteMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadCompleteMultipartUploadRequest {
    readonly idempotencyKey: string

    readonly cloudCompleteMultipartUploadRequestModel: CloudCompleteMultipartUploadRequestModel

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for uploadCreateMultipartUpload operation in CloudApi.
 */
export interface CloudApiUploadCreateMultipartUploadRequest {
    readonly cloudCreateMultipartUploadRequestModel: CloudCreateMultipartUploadRequestModel

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for uploadGetMultipartPartUrl operation in CloudApi.
 */
export interface CloudApiUploadGetMultipartPartUrlRequest {
    readonly cloudGetMultipartPartUrlRequestModel: CloudGetMultipartPartUrlRequestModel

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * Request parameters for uploadPart operation in CloudApi.
 */
export interface CloudApiUploadPartRequest {
    readonly contentMd5: string

    readonly key: string

    readonly uploadId: string

    readonly partNumber: number

    readonly file: File

    /**
     * Session token for encrypted folder access
     */
    readonly xFolderSession?: string
}

/**
 * CloudApi - object-oriented interface
 */
export class CloudApi extends BaseAPI {
    /**
     * Deletes one or more objects (or directories) belonging to the authenticated user.
     * @summary Delete objects
     * @param {CloudApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: CloudApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration)._delete(requestParameters.idempotencyKey, requestParameters.cloudDeleteRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Marks an existing directory as encrypted. Provide passphrase via X-Folder-Passphrase header.
     * @summary Convert a directory to encrypted
     * @param {CloudApiDirectoryConvertToEncryptedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryConvertToEncrypted(requestParameters: CloudApiDirectoryConvertToEncryptedRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryConvertToEncrypted(requestParameters.xFolderPassphrase, requestParameters.directoryConvertToEncryptedRequestModel, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new directory. For encrypted directories, set IsEncrypted=true and provide passphrase via X-Folder-Passphrase header.
     * @summary Create a directory
     * @param {CloudApiDirectoryCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryCreate(requestParameters: CloudApiDirectoryCreateRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryCreate(requestParameters.directoryCreateRequestModel, requestParameters.xFolderPassphrase, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes encryption from a directory (keeps files). Provide passphrase via X-Folder-Passphrase header.
     * @summary Remove encryption from a directory
     * @param {CloudApiDirectoryDecryptRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryDecrypt(requestParameters: CloudApiDirectoryDecryptRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryDecrypt(requestParameters.xFolderPassphrase, requestParameters.directoryDecryptRequestModel, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a directory and all its contents. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
     * @summary Delete a directory
     * @param {CloudApiDirectoryDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryDelete(requestParameters: CloudApiDirectoryDeleteRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryDelete(requestParameters.directoryDeleteRequestModel, requestParameters.xFolderPassphrase, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the session token for an encrypted directory.
     * @summary Lock an encrypted directory
     * @param {CloudApiDirectoryLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryLock(requestParameters: CloudApiDirectoryLockRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryLock(requestParameters.directoryLockRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Renames a directory. For encrypted directories, provide passphrase via X-Folder-Passphrase header.
     * @summary Rename a directory
     * @param {CloudApiDirectoryRenameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryRename(requestParameters: CloudApiDirectoryRenameRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryRename(requestParameters.directoryRenameRequestModel, requestParameters.xFolderPassphrase, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates passphrase and creates a session token for subsequent access. The session token should be passed via X-Folder-Session header in subsequent requests.
     * @summary Unlock an encrypted directory
     * @param {CloudApiDirectoryUnlockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public directoryUnlock(requestParameters: CloudApiDirectoryUnlockRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).directoryUnlock(requestParameters.xFolderPassphrase, requestParameters.directoryUnlockRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a file that belongs to the authenticated user. The server enforces a static per-user download speed (bytes/sec).
     * @summary Download a file for the authenticated user (streamed)
     * @param {CloudApiDownloadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public download(requestParameters: CloudApiDownloadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).download(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a zip extraction job if it is pending or running.
     * @summary Cancel zip extraction
     * @param {CloudApiExtractZipCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public extractZipCancel(requestParameters: CloudApiExtractZipCancelRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).extractZipCancel(requestParameters.cloudExtractZipCancelRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts an async job to extract a previously uploaded .zip file.
     * @summary Start zip extraction
     * @param {CloudApiExtractZipStartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public extractZipStart(requestParameters: CloudApiExtractZipStartRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).extractZipStart(requestParameters.cloudExtractZipStartRequestModel, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current status/progress of a zip extraction job.
     * @summary Get zip extraction status
     * @param {CloudApiExtractZipStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public extractZipStatus(requestParameters: CloudApiExtractZipStatusRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).extractZipStatus(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Find a single object by key (user scoped) and return its metadata.
     * @summary Get object metadata
     * @param {CloudApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: CloudApiFindRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).find(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a presigned URL for a specific object key to allow direct client access.
     * @summary Get a presigned URL for upload/download
     * @param {CloudApiGetPresignedUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getPresignedUrl(requestParameters: CloudApiGetPresignedUrlRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).getPresignedUrl(requestParameters.key, requestParameters.expiresInSeconds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a view (breadcrumbs, directories and objects) for the given user-scoped path. Supports delimiter and metadata processing flags. For encrypted folders, provide session token via X-Folder-Session header.
     * @summary List files and directories
     * @param {CloudApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: CloudApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).list(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns breadcrumb entries (path pieces) for the supplied path.
     * @summary Get breadcrumb for a path
     * @param {CloudApiListBreadcrumbRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listBreadcrumb(requestParameters: CloudApiListBreadcrumbRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listBreadcrumb(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns directory prefixes (folders) for a given path. For encrypted folders, provide session token via X-Folder-Session header.
     * @summary List directories inside a path
     * @param {CloudApiListDirectoriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDirectories(requestParameters: CloudApiListDirectoriesRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listDirectories(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns files at a given path for the authenticated user. For encrypted folders, provide session token via X-Folder-Session header.
     * @summary List objects (files) inside a path
     * @param {CloudApiListObjectsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listObjects(requestParameters: CloudApiListObjectsRequest = {}, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).listObjects(requestParameters.search, requestParameters.skip, requestParameters.take, requestParameters.path, requestParameters.delimiter, requestParameters.isMetadataProcessing, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Move an object from SourceKey to DestinationKey within the user scope.
     * @summary Move/rename an object
     * @param {CloudApiMoveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public move(requestParameters: CloudApiMoveRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).move(requestParameters.idempotencyKey, requestParameters.cloudMoveRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest antivirus scan status for the given object key.
     * @summary Get antivirus scan status for a file
     * @param {CloudApiScanStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scanStatus(requestParameters: CloudApiScanStatusRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).scanStatus(requestParameters.key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing object by changing metadata or renaming the file (name only).
     * @summary Update object metadata or rename
     * @param {CloudApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public update(requestParameters: CloudApiUpdateRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).update(requestParameters.cloudUpdateRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Abort an ongoing multipart upload and clean up temporary state.
     * @summary Abort a multipart upload
     * @param {CloudApiUploadAbortMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadAbortMultipartUpload(requestParameters: CloudApiUploadAbortMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadAbortMultipartUpload(requestParameters.cloudAbortMultipartUploadRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Completes a multipart upload by providing the list of parts and finalizes the object.
     * @summary Complete multipart upload
     * @param {CloudApiUploadCompleteMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadCompleteMultipartUpload(requestParameters: CloudApiUploadCompleteMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadCompleteMultipartUpload(requestParameters.idempotencyKey, requestParameters.cloudCompleteMultipartUploadRequestModel, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates an UploadId and starts a multipart upload flow.
     * @summary Create a multipart upload session
     * @param {CloudApiUploadCreateMultipartUploadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadCreateMultipartUpload(requestParameters: CloudApiUploadCreateMultipartUploadRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadCreateMultipartUpload(requestParameters.cloudCreateMultipartUploadRequestModel, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an expiring URL to upload a single part for the provided UploadId and PartNumber.
     * @summary Get a multipart upload part URL
     * @param {CloudApiUploadGetMultipartPartUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadGetMultipartPartUrl(requestParameters: CloudApiUploadGetMultipartPartUrlRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadGetMultipartPartUrl(requestParameters.cloudGetMultipartPartUrlRequestModel, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accepts a single file part for a multipart upload. The request must be multipart/form-data.
     * @summary Upload a multipart part
     * @param {CloudApiUploadPartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public uploadPart(requestParameters: CloudApiUploadPartRequest, options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).uploadPart(requestParameters.contentMd5, requestParameters.key, requestParameters.uploadId, requestParameters.partNumber, requestParameters.file, requestParameters.xFolderSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the authenticated user storage usage and limits.
     * @summary Get user\'s storage usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public userStorageUsage(options?: RawAxiosRequestConfig) {
        return CloudApiFp(this.configuration).userStorageUsage(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefinitionApi - axios parameter creator
 */
export const DefinitionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDefinition: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Find/{groupCode}/{code}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Group/Find/{groupCode}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} groupCode 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefinition: async (groupCode: string, search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupCode' is not null or undefined
            assertParamExists('listDefinition', 'groupCode', groupCode)
            const localVarPath = `/Api/Definition/List/{groupCode}`
                .replace(`{${"groupCode"}}`, encodeURIComponent(String(groupCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup: async (search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Definition/Group/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefinitionApi - functional programming interface
 */
export const DefinitionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefinitionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDefinition(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDefinition(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.findDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.findGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} groupCode 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDefinition(groupCode: string, search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDefinition(groupCode, search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.listDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroup(search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefinitionGroupResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroup(search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefinitionApi.listGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefinitionApi - factory interface
 */
export const DefinitionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefinitionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDefinition(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findDefinition(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findGroup(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefinitionApiListDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDefinition(requestParameters: DefinitionApiListDefinitionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listDefinition(requestParameters.groupCode, requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefinitionApiListGroupRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroup(requestParameters: DefinitionApiListGroupRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DefinitionGroupResponseListBaseModel> {
            return localVarFp.listGroup(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for listDefinition operation in DefinitionApi.
 */
export interface DefinitionApiListDefinitionRequest {
    readonly groupCode: string

    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * Request parameters for listGroup operation in DefinitionApi.
 */
export interface DefinitionApiListGroupRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * DefinitionApi - object-oriented interface
 */
export class DefinitionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findDefinition(options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).findDefinition(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findGroup(options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).findGroup(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefinitionApiListDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listDefinition(requestParameters: DefinitionApiListDefinitionRequest, options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).listDefinition(requestParameters.groupCode, requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefinitionApiListGroupRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listGroup(requestParameters: DefinitionApiListGroupRequest = {}, options?: RawAxiosRequestConfig) {
        return DefinitionApiFp(this.configuration).listGroup(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async check(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Check200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.check(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.check']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        check(options?: RawAxiosRequestConfig): AxiosPromise<Check200Response> {
            return localVarFp.check(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public check(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).check(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HomeApi - axios parameter creator
 */
export const HomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HomeApi - functional programming interface
 */
export const HomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HomeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async home(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StringResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.home(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HomeApi.home']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HomeApi - factory interface
 */
export const HomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HomeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        home(options?: RawAxiosRequestConfig): AxiosPromise<StringResponseModel> {
            return localVarFp.home(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HomeApi - object-oriented interface
 */
export class HomeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public home(options?: RawAxiosRequestConfig) {
        return HomeApiFp(this.configuration).home(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionApi - axios parameter creator
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/Api/Subscription/Delete/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeAsAdminRequestModel} subscribeAsAdminRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign: async (subscribeAsAdminRequestModel: SubscribeAsAdminRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeAsAdminRequestModel' is not null or undefined
            assertParamExists('assign', 'subscribeAsAdminRequestModel', subscribeAsAdminRequestModel)
            const localVarPath = `/Api/Subscription/Assign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeAsAdminRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscriptionPostBodyRequestModel} subscriptionPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (subscriptionPostBodyRequestModel: SubscriptionPostBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionPostBodyRequestModel' is not null or undefined
            assertParamExists('create', 'subscriptionPostBodyRequestModel', subscriptionPostBodyRequestModel)
            const localVarPath = `/Api/Subscription/Create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPostBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {SubscriptionPutBodyRequestModel} subscriptionPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (id: string, subscriptionPutBodyRequestModel: SubscriptionPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edit', 'id', id)
            // verify required parameter 'subscriptionPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'subscriptionPutBodyRequestModel', subscriptionPutBodyRequestModel)
            const localVarPath = `/Api/Subscription/Edit/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscriptionPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('find', 'id', id)
            const localVarPath = `/Api/Subscription/Find/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Subscription/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        my: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Subscription/My`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubscribeRequestModel} subscribeRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe: async (subscribeRequestModel: SubscribeRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscribeRequestModel' is not null or undefined
            assertParamExists('subscribe', 'subscribeRequestModel', subscribeRequestModel)
            const localVarPath = `/Api/Subscription/My/Subscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subscribeRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unsubscribe', 'id', id)
            const localVarPath = `/Api/Subscription/Unsubscribe/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe_1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/Subscription/My/Unsubscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeAsAdminRequestModel} subscribeAsAdminRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assign(subscribeAsAdminRequestModel: SubscribeAsAdminRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assign(subscribeAsAdminRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.assign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscriptionPostBodyRequestModel} subscriptionPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(subscriptionPostBodyRequestModel: SubscriptionPostBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(subscriptionPostBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {SubscriptionPutBodyRequestModel} subscriptionPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(id: string, subscriptionPutBodyRequestModel: SubscriptionPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(id, subscriptionPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionFindResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionListResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async my(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.my(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.my']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SubscribeRequestModel} subscribeRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subscribe(subscribeRequestModel: SubscribeRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subscribe(subscribeRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.subscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.unsubscribe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unsubscribe_1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unsubscribe_1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.unsubscribe_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * 
         * @param {SubscriptionApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: SubscriptionApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp._delete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiAssignRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assign(requestParameters: SubscriptionApiAssignRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.assign(requestParameters.subscribeAsAdminRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: SubscriptionApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.create(requestParameters.subscriptionPostBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: SubscriptionApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.id, requestParameters.subscriptionPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: SubscriptionApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionFindResponseBaseModel> {
            return localVarFp.find(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionListResponseListBaseModel> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        my(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.my(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiSubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subscribe(requestParameters: SubscriptionApiSubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.subscribe(requestParameters.subscribeRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionApiUnsubscribeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe(requestParameters: SubscriptionApiUnsubscribeRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.unsubscribe(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unsubscribe_1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unsubscribe_1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in SubscriptionApi.
 */
export interface SubscriptionApiDeleteRequest {
    readonly id: string
}

/**
 * Request parameters for assign operation in SubscriptionApi.
 */
export interface SubscriptionApiAssignRequest {
    readonly subscribeAsAdminRequestModel: SubscribeAsAdminRequestModel
}

/**
 * Request parameters for create operation in SubscriptionApi.
 */
export interface SubscriptionApiCreateRequest {
    readonly subscriptionPostBodyRequestModel: SubscriptionPostBodyRequestModel
}

/**
 * Request parameters for edit operation in SubscriptionApi.
 */
export interface SubscriptionApiEditRequest {
    readonly id: string

    readonly subscriptionPutBodyRequestModel: SubscriptionPutBodyRequestModel
}

/**
 * Request parameters for find operation in SubscriptionApi.
 */
export interface SubscriptionApiFindRequest {
    readonly id: string
}

/**
 * Request parameters for subscribe operation in SubscriptionApi.
 */
export interface SubscriptionApiSubscribeRequest {
    readonly subscribeRequestModel: SubscribeRequestModel
}

/**
 * Request parameters for unsubscribe operation in SubscriptionApi.
 */
export interface SubscriptionApiUnsubscribeRequest {
    readonly id: string
}

/**
 * SubscriptionApi - object-oriented interface
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * 
     * @param {SubscriptionApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: SubscriptionApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiAssignRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public assign(requestParameters: SubscriptionApiAssignRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).assign(requestParameters.subscribeAsAdminRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: SubscriptionApiCreateRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).create(requestParameters.subscriptionPostBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: SubscriptionApiEditRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).edit(requestParameters.id, requestParameters.subscriptionPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: SubscriptionApiFindRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).find(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public my(options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).my(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiSubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public subscribe(requestParameters: SubscriptionApiSubscribeRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).subscribe(requestParameters.subscribeRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionApiUnsubscribeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsubscribe(requestParameters: SubscriptionApiUnsubscribeRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).unsubscribe(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public unsubscribe_1(options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).unsubscribe_1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/Api/User/Delete/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserPostBodyRequestModel} userPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (userPostBodyRequestModel: UserPostBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPostBodyRequestModel' is not null or undefined
            assertParamExists('create', 'userPostBodyRequestModel', userPostBodyRequestModel)
            const localVarPath = `/Api/User/Create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPostBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserPutBodyRequestModel} userPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit: async (id: string, userPutBodyRequestModel: UserPutBodyRequestModel, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('edit', 'id', id)
            // verify required parameter 'userPutBodyRequestModel' is not null or undefined
            assertParamExists('edit', 'userPutBodyRequestModel', userPutBodyRequestModel)
            const localVarPath = `/Api/User/Edit/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPutBodyRequestModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('find', 'id', id)
            const localVarPath = `/Api/User/Find/{id}`
                .replace(`{${"Id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (search?: string, skip?: number, take?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/Api/User/List`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication cookie required

            if (search !== undefined) {
                localVarQueryParameter['Search'] = search;
            }

            if (skip !== undefined) {
                localVarQueryParameter['Skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['Take'] = take;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UserPostBodyRequestModel} userPostBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(userPostBodyRequestModel: UserPostBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(userPostBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UserPutBodyRequestModel} userPutBodyRequestModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async edit(id: string, userPutBodyRequestModel: UserPutBodyRequestModel, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BooleanResponseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.edit(id, userPutBodyRequestModel, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.edit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFindResponseBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [search] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(search?: string, skip?: number, take?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponseListBaseModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(search, skip, take, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {UserApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: UserApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp._delete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: UserApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.create(requestParameters.userPostBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiEditRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        edit(requestParameters: UserApiEditRequest, options?: RawAxiosRequestConfig): AxiosPromise<BooleanResponseModel> {
            return localVarFp.edit(requestParameters.id, requestParameters.userPutBodyRequestModel, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters: UserApiFindRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserFindResponseBaseModel> {
            return localVarFp.find(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: UserApiListRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UserListResponseListBaseModel> {
            return localVarFp.list(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in UserApi.
 */
export interface UserApiDeleteRequest {
    readonly id: string
}

/**
 * Request parameters for create operation in UserApi.
 */
export interface UserApiCreateRequest {
    readonly userPostBodyRequestModel: UserPostBodyRequestModel
}

/**
 * Request parameters for edit operation in UserApi.
 */
export interface UserApiEditRequest {
    readonly id: string

    readonly userPutBodyRequestModel: UserPutBodyRequestModel
}

/**
 * Request parameters for find operation in UserApi.
 */
export interface UserApiFindRequest {
    readonly id: string
}

/**
 * Request parameters for list operation in UserApi.
 */
export interface UserApiListRequest {
    readonly search?: string

    readonly skip?: number

    readonly take?: number
}

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public _delete(requestParameters: UserApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public create(requestParameters: UserApiCreateRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).create(requestParameters.userPostBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiEditRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public edit(requestParameters: UserApiEditRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).edit(requestParameters.id, requestParameters.userPutBodyRequestModel, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public find(requestParameters: UserApiFindRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).find(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public list(requestParameters: UserApiListRequest = {}, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).list(requestParameters.search, requestParameters.skip, requestParameters.take, options).then((request) => request(this.axios, this.basePath));
    }
}



